<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Olympia Gallery - Final & Fast</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s;
        }
        #loading-text { font-size: 1.2rem; margin-bottom: 20px; letter-spacing: 2px; }
        #progress-bar { width: 200px; height: 4px; background: #333; border-radius: 2px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #fff; transition: width 0.2s; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 50;
            display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center; backdrop-filter: blur(5px);
        }
        
        #start-btn {
            margin-top: 30px; padding: 20px 60px; font-size: 1.2rem; font-weight: bold;
            color: black; background: white; border: none; border-radius: 50px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: transform 0.2s; z-index: 51; box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #start-btn:active { transform: scale(0.95); background: #ffff00; }

        #instructions { margin-top: 20px; color: #aaa; font-size: 0.9rem; line-height: 1.6; max-width: 85%; }
        .key { display: inline-block; border: 1px solid #777; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; color: #fff; }

        #cursor {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: white;
            border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.8; pointer-events: none; mix-blend-mode: difference;
            z-index: 5; transition: transform 0.15s;
        }
        .hover-active { transform: translate(-50%, -50%) scale(2.0) !important; background: #00ff66 !important; }

        #sit-hint {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            color: white; background: rgba(0,0,0,0.6); padding: 10px 20px;
            border-radius: 20px; font-size: 0.9rem; display: none; pointer-events: none; z-index: 20;
        }
        
        /* --- NEW FLOATING JOYSTICK STYLES --- */
        .joystick-visual {
            position: absolute; width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; pointer-events: none; display: none; z-index: 40;
            transform: translate(-50%, -50%);
        }
        .joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        #artwork-modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.98); z-index: 60;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; cursor: pointer; color: white;
        }
        #modal-img { max-height: 80vh; max-width: 95%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin-bottom: 20px; object-fit: contain; }
        #modal-info { max-width: 600px; padding: 0 20px; }
        #modal-title { font-weight: 800; font-size: 1.5rem; margin: 0 0 5px 0; text-transform: uppercase; }
        
        #mobile-sit-btn {
            position: absolute; right: 30px; bottom: 150px; 
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid white;
            color: white; font-weight: bold; display: none; z-index: 45;
            align-items: center; justify-content: center; cursor: pointer;
            backdrop-filter: blur(5px);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="cursor"></div>
    <div id="sit-hint">Натисни <span class="key">C</span> щоб сісти</div>
    
    <div id="loading-screen">
        <div id="loading-text">ЗАВАНТАЖЕННЯ...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="start-screen">
        <h1>EXHIBITION 2025</h1>
        <div id="instructions">
            <p>ПК: <span class="key">WASD</span> рух &nbsp; <span class="key">C</span> сісти</p>
            <p>Мобільний: Ліва частина екрану - Рух, Права - Огляд</p>
        </div>
        <button id="start-btn" type="button">УВІЙТИ</button>
    </div>

    <div id="joy-left" class="joystick-visual"><div class="joystick-knob"></div></div>
    <div id="joy-right" class="joystick-visual"><div class="joystick-knob"></div></div>
    <div id="mobile-sit-btn">SIT</div>

    <audio id="bgMusic" loop preload="auto">
        <source src="assets/song.mp3" type="audio/mpeg">
    </audio>

    <video id="video1" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video1.mp4" type="video/mp4">
    </video>
    <video id="video2" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video2.mp4" type="video/mp4">
    </video>

    <div id="artwork-modal">
        <img id="modal-img" src="" alt="Artwork">
        <div id="modal-info">
            <div id="modal-title">TITLE</div>
            <p id="modal-desc">Description</p>
            <p style="font-size: 0.8rem; margin-top: 20px; color: #888;">TAP TO CLOSE</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- MANAGER ---
        const manager = new THREE.LoadingManager();
        manager.onProgress = function (item, loaded, total) {
            const percent = (loaded / total) * 100;
            document.getElementById('progress-fill').style.width = percent + '%';
        };
        manager.onLoad = function () {
            document.getElementById('loading-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
                checkRoomLoad(0);
            }, 500);
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.Fog(0xffffff, 5, 50); 

        RectAreaLightUniformsLib.init();

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.7, 8); 
        camera.rotation.order = 'YXZ'; 

        // --- OPTIMIZATION FOR LAPTOPS ---
        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // LIMIT PIXEL RATIO (Crucial for performance on Retina/HighDPI)
        const maxPixelRatio = isMobile ? 1.0 : 1.25; 
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, maxPixelRatio));
        
        renderer.outputColorSpace = THREE.SRGBColorSpace; 
        renderer.toneMapping = THREE.NoToneMapping; 

        if (isMobile) {
            renderer.shadowMap.enabled = false; 
        } else {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        document.body.appendChild(renderer.domElement);

        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.5;

        // --- MATERIALS ---
        const textureLoader = new THREE.TextureLoader(manager);
        const concreteTex = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/plaster_grey_04/plaster_grey_04_diff_1k.jpg');
        concreteTex.wrapS = concreteTex.wrapT = THREE.RepeatWrapping;
        concreteTex.repeat.set(10, 40); concreteTex.colorSpace = THREE.SRGBColorSpace;

        const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const floorMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
        const darkWallMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
        const darkFloorMat = new THREE.MeshStandardMaterial({ color: 0x020202, roughness: 0.9 });
        const tvFrameMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const cableMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const benchMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.3 });
        const mobilePosterMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6, metalness: 0.1 });

        const video1 = document.getElementById('video1');
        const video2 = document.getElementById('video2');
        let videoTex1 = new THREE.VideoTexture(video1);
        let videoTex2 = new THREE.VideoTexture(video2);
        videoTex1.colorSpace = THREE.SRGBColorSpace;
        videoTex2.colorSpace = THREE.SRGBColorSpace;

        const collidableObjects = []; 
        const postersArray = []; 
        let revolvingStage = null;
        const animatedModels = [];

        let currentImageId = 1;
        const totalImages = 65; 

        function getNextImage() {
            const id = currentImageId;
            let wallUrl;
            if (isMobile) { wallUrl = `assets/small_mobile/image${id}.jpg`; } else { wallUrl = `assets/small/image${id}.jpg`; }
            const fullUrl = `assets/image${id}.png`; 
            const title = `Artwork #${id}`;
            currentImageId++; if (currentImageId > totalImages) currentImageId = 1; 
            return { wallUrl, fullUrl, title, id };
        }

        const pendingPosters = {}; const roomsLoaded = {}; const lazyLoader = new THREE.TextureLoader();

        function loadRoomTextures(roomIndex) {
            if (roomsLoaded[roomIndex]) return; 
            if (!pendingPosters[roomIndex]) return; 
            roomsLoaded[roomIndex] = true;
            const items = pendingPosters[roomIndex];
            items.forEach(item => {
                lazyLoader.load(item.url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    const newMat = new THREE.MeshStandardMaterial({ map: tex, color: 0xffffff, roughness: 0.4, side: item.side || THREE.FrontSide });
                    item.mesh.material = newMat; item.mesh.material.needsUpdate = true;
                }, undefined, () => {
                    // Fallback to generic png if jpg fails
                    const pngUrl = item.url.replace('small_mobile/', '').replace('small/', '').replace('.jpg', '.png');
                    lazyLoader.load(pngUrl, (tex2)=>{
                        tex2.colorSpace = THREE.SRGBColorSpace;
                        const newMat = new THREE.MeshStandardMaterial({ map: tex2, color: 0xffffff, roughness: 0.4, side: item.side || THREE.FrontSide });
                        item.mesh.material = newMat;
                    });
                });
            });
        }

        // Modified signature to accept specific URL
        function addPoster(x, y, z, ry, w, h, roomIndex, specificUrl = null) {
            let data;
            if (specificUrl) {
                // Manually create data object for specific poster (image80)
                data = { 
                    wallUrl: specificUrl, 
                    fullUrl: specificUrl, // Uses same for full view
                    title: "Special Artwork", 
                    id: 80 
                };
            } else {
                data = getNextImage();
            }

            const geo = new THREE.PlaneGeometry(w, h);
            const mesh = new THREE.Mesh(geo, mobilePosterMat);
            mesh.position.set(x, y, z); mesh.rotation.y = ry;
            mesh.userData = { isPoster: true, url: data.fullUrl, title: data.title, year: "2025", desc: "Collection" };
            scene.add(mesh); postersArray.push(mesh); 
            
            if (!pendingPosters[roomIndex]) pendingPosters[roomIndex] = [];
            pendingPosters[roomIndex].push({ mesh: mesh, url: data.wallUrl, side: THREE.FrontSide });
        }

        function createBox(x, y, z, w, h, d, isWall = true, isDark = false, customMat = null) {
            let mat = customMat ? customMat : (isDark ? (isWall ? darkWallMat : darkFloorMat) : (isWall ? wallMat : floorMat));
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z); mesh.receiveShadow = !isMobile;
            if(isWall) { mesh.castShadow = (!isMobile && !isDark); mesh.updateMatrixWorld(); collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) }); }
            scene.add(mesh);
        }

        function createDoorWall(z, width, height, isDark = false) {
            const doorW = 4, doorH = 3.5, sideW = (width - doorW) / 2, thick = 0.5;
            createBox(-(width/2) + (sideW/2), height/2, z, sideW, height, thick, true, isDark);
            createBox((width/2) - (sideW/2), height/2, z, sideW, height, thick, true, isDark);
            createBox(0, doorH + (height-doorH)/2, z, doorW, height-doorH, thick, true, isDark);
        }

        function createHangingTV(x, z, ceilingHeight, rotationY = 0) {
            const tvW = 1.78; const tvH = 3.16; const tvD = 0.1;
            const tvGeo = new THREE.BoxGeometry(tvW, tvH, tvD);
            const screenMat = new THREE.MeshBasicMaterial({ map: videoTex2 });
            const materials = [tvFrameMat, tvFrameMat, tvFrameMat, tvFrameMat, screenMat, tvFrameMat];
            const tv = new THREE.Mesh(tvGeo, materials);
            const tvY = 3.0; 
            tv.position.set(x, tvY, z); tv.rotation.y = rotationY; scene.add(tv);
            const tvTopY = tvY + (tvH / 2);
            const cableLen = ceilingHeight - tvTopY;
            const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen > 0 ? cableLen : 0.1);
            cableGeo.translate(0, cableLen / 2, 0); 
            const c1 = new THREE.Mesh(cableGeo, cableMat); c1.position.set(-tvW*0.3, tvH/2, 0); tv.add(c1);
            const c2 = new THREE.Mesh(cableGeo, cableMat); c2.position.set(tvW*0.3, tvH/2, 0); tv.add(c2);
            if (!isMobile) { const screenLight = new THREE.PointLight(0xffffff, 8, 7); screenLight.position.set(0, 0, 1.0); tv.add(screenLight); }
            tv.userData.isObstacle = true; 
            collidableObjects.push({ customType: 'cylinder', mesh: tv, radius: 0.4, position: tv.position });
        }

        function createProjection(x, y, z, w, h, rotationY, texture) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
            mesh.position.set(x, y, z); mesh.rotation.y = rotationY; scene.add(mesh);
            if(!isMobile) { const light = new THREE.PointLight(0xaaaaff, 30, 25); light.position.set(x + Math.sin(rotationY), y, z + Math.cos(rotationY)); scene.add(light); }
        }

        function createScaffoldingStructure(x, z, roomIndex) {
            revolvingStage = new THREE.Group();
            revolvingStage.position.set(x, 0, z);
            const platform = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.5 }));
            platform.position.y = 0.1; platform.receiveShadow = !isMobile; revolvingStage.add(platform);
            collidableObjects.push({ box: new THREE.Box3().setFromObject(platform) }); 
            const structureGroup = new THREE.Group(); structureGroup.position.y = 0.2; 
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
            const w = 4; const h = 3.5; const d = 4; const r = 0.05;
            function addPipe(px, py, pz, height, axis) {
                const mesh = new THREE.Mesh(new THREE.CylinderGeometry(r, r, height), metalMat);
                mesh.position.set(px, py, pz);
                if (axis === 'z') mesh.rotation.x = Math.PI / 2; if (axis === 'x') mesh.rotation.z = Math.PI / 2;
                mesh.castShadow = !isMobile; structureGroup.add(mesh); collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) });
            }
            function addJoint(jx, jy, jz) { const mesh = new THREE.Mesh(new THREE.SphereGeometry(r * 1.8), metalMat); mesh.position.set(jx, jy, jz); structureGroup.add(mesh); }
            addPipe(-w/2, h/2, -d/2, h, 'y'); addPipe(w/2, h/2, -d/2, h, 'y'); addPipe(-w/2, h/2, d/2, h, 'y'); addPipe(w/2, h/2, d/2, h, 'y');
            const levels = [0.2, h - 0.2];
            levels.forEach(lev => { addPipe(0, lev, -d/2, w, 'x'); addPipe(0, lev, d/2, w, 'x'); addPipe(-w/2, lev, 0, d, 'z'); addPipe(w/2, lev, 0, d, 'z'); });
            const cornersX = [-w/2, w/2]; const cornersZ = [-d/2, d/2];
            levels.forEach(lev => { cornersX.forEach(cx => { cornersZ.forEach(cz => { addJoint(cx, lev, cz); }); }); });
            
            function mountPoster(px, py, pz, ry, width, height, pipeYLevel, specificUrl = null) {
                let data;
                if(specificUrl) {
                    data = { wallUrl: specificUrl, fullUrl: specificUrl, title: "Special", id: 80 };
                } else {
                    data = getNextImage();
                }

                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.5), mobilePosterMat);
                mesh.material.side = THREE.DoubleSide; 
                mesh.position.set(px, py, pz); mesh.rotation.y = ry;
                const stringMat = new THREE.LineBasicMaterial({ color: 0x111111 });
                const pW = 2.0; const pH = 2.5; const topOfPosterY = pH / 2; const distToPipe = (pipeYLevel - r) - (py + topOfPosterY);
                const pointsL = [new THREE.Vector3(-pW/2 + 0.15, topOfPosterY, 0), new THREE.Vector3(-pW/2 + 0.15, topOfPosterY + distToPipe, 0)];
                const pointsR = [new THREE.Vector3(pW/2 - 0.15, topOfPosterY, 0), new THREE.Vector3(pW/2 - 0.15, topOfPosterY + distToPipe, 0)];
                mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsL), stringMat)); mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsR), stringMat));
                mesh.userData = { isPoster: true, url: data.fullUrl, title: data.title, year: "2025", desc: "Mounted Installation" };
                structureGroup.add(mesh); postersArray.push(mesh);
                if (!pendingPosters[roomIndex]) pendingPosters[roomIndex] = [];
                pendingPosters[roomIndex].push({ mesh: mesh, url: data.wallUrl, side: THREE.DoubleSide });
            }
            const topPipeLevel = h - 0.2; const posterCenterY = h / 2;
            
            // Existing posters
            mountPoster(0, posterCenterY, d/2, 0, 2, 2.5, topPipeLevel); 
            mountPoster(-w/2, posterCenterY, 0, Math.PI/2, 2, 2.5, topPipeLevel); 
            mountPoster(0, posterCenterY, -d/2, Math.PI, 2.5, 1.8, topPipeLevel); 
            
            // --- NEW POSTER 4 (RIGHT SIDE) ---
            mountPoster(w/2, posterCenterY, 0, -Math.PI/2, 2, 2.5, topPipeLevel, 'assets/image80.jpg');

            revolvingStage.add(structureGroup); scene.add(revolvingStage);
        }

        // --- GLB FIX: LIGHTING & MATERIAL ---
        function fixMaterial(object) {
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = false; 
                    child.receiveShadow = !isMobile;
                    
                    if (child.material) {
                        child.material.metalness = 0; 
                        child.material.roughness = 0.8; 
                    }
                }
            });
        }

        const modelFiles = ['1.glb', '2.glb', '3.glb', '4.glb', '5.glb', '6.glb', '8.glb'];
        
        function loadAllModels(roomCenterX, roomCenterZ) {
            const gltfLoader = new GLTFLoader(manager);
            
            modelFiles.forEach((filename, index) => {
                const angle = (index / modelFiles.length) * Math.PI * 2;
                const radius = 5; 
                const offsetX = Math.cos(angle) * radius; const offsetZ = Math.sin(angle) * radius;
                const fullPath = `assets/3d/${filename}`;
                
                gltfLoader.load(fullPath, (gltf) => {
                    const object = gltf.scene;
                    fixMaterial(object);

                    object.scale.set(1, 1, 1); 
                    const box = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let targetScale = 1.0;
                    if (maxDim > 5) { targetScale = 3.0 / maxDim; } else if (maxDim < 0.5) { targetScale = 2.0 / maxDim; }
                    
                    let multiplier = 2.3; 
                    if (filename === '3.glb') { multiplier *= 0.8; }
                    if (filename === '5.glb' || filename === '6.glb') { multiplier = 1.9; }
                    if (filename === '8.glb') { multiplier = (2.3 / 3.0) * 1.4; } 

                    targetScale *= multiplier;
                    object.scale.set(targetScale, targetScale, targetScale);
                    object.rotation.set(0, 0, 0); 

                    if (filename === '4.glb') { animatedModels.push(object); }

                    object.updateMatrixWorld(); 
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.set(roomCenterX + offsetX, -newBox.min.y, roomCenterZ + offsetZ);
                    scene.add(object);
                    collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                    
                    // 6 + 9 stack
                    if (filename === '6.glb') {
                        const loader9 = new GLTFLoader();
                        loader9.load('assets/3d/9.glb', (gltf9) => {
                            const obj9 = gltf9.scene;
                            fixMaterial(obj9);

                            const smallScale = (((1.9 / 4.0) * 1.4) / 3.0) * 1.5;
                            
                            obj9.scale.set(smallScale, smallScale, smallScale); 
                            obj9.rotation.set(0, 0, 0);
                            
                            animatedModels.push(obj9); 
                            
                            const box6 = new THREE.Box3().setFromObject(object);
                            const topY = box6.max.y;
                            obj9.updateMatrixWorld();
                            const box9 = new THREE.Box3().setFromObject(obj9);
                            const heightOffset9 = -box9.min.y; 
                            
                            obj9.position.set(object.position.x, topY * 1.45 + heightOffset9, object.position.z);
                            scene.add(obj9);
                        });
                    }
                }, undefined, (e) => {
                    console.error("Failed to load model:", filename);
                });
            });
        }

        function createHangingModel7(x, z, roomCeiling) {
            const gltfLoader = new GLTFLoader(manager);
            gltfLoader.load('assets/3d/7.glb', (gltf) => {
                const object = gltf.scene;
                fixMaterial(object);
                object.scale.set(1.4, 1.4, 1.4); 
                object.rotation.set(0, 0, 0); 
                const hangY = 3.0; 
                object.position.set(x, hangY, z);
                scene.add(object);
                collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                const cableLen = roomCeiling - hangY;
                const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen);
                cableGeo.translate(0, cableLen/2, 0);
                const cable = new THREE.Mesh(cableGeo, cableMat);
                cable.position.set(x, hangY, z);
                scene.add(cable);
            });
        }

        // --- 5. ГЕНЕРАЦІЯ СВІТУ ---
        const roomSize = 20; const roomHeight = 6; const roomsCount = 5;
        const whiteFloorL = roomSize * (roomsCount - 1);
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, whiteFloorL), floorMat);
        floor1.rotation.x = -Math.PI / 2; floor1.position.z = -whiteFloorL / 2 + roomSize / 2; floor1.receiveShadow = !isMobile; scene.add(floor1);
        const zLastRoom = -((roomsCount - 1) * roomSize);
        let benchPosition = new THREE.Vector3(0, 0, 0); 
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkFloorMat);
        floor2.rotation.x = -Math.PI / 2; floor2.position.z = zLastRoom; scene.add(floor2);

        for (let i = 0; i < roomsCount; i++) {
            const zCenter = -(i * roomSize);
            const isDarkRoom = (i === roomsCount - 1);
            if (!isDarkRoom && !isMobile) {
                const rectLightLeft = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                rectLightLeft.position.set(-8, 5.5, zCenter); rectLightLeft.lookAt(-20, 1, zCenter); scene.add(rectLightLeft);
                const rectLightRight = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                rectLightRight.position.set(8, 5.5, zCenter); rectLightRight.lookAt(20, 1, zCenter); scene.add(rectLightRight);
                const fillLight = new THREE.PointLight(0xffffff, 2, 20); fillLight.position.set(0, 5, zCenter); scene.add(fillLight);
            }
            else if (!isDarkRoom && isMobile) {
                 const simpleLight = new THREE.PointLight(0xffffff, 1.5, 15);
                 simpleLight.position.set(0, 4, zCenter); scene.add(simpleLight);
            }

            createBox(-roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom); 
            createBox(roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom); 
            if (!isDarkRoom) {
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), wallMat);
                ceiling.rotation.x = Math.PI / 2; ceiling.position.set(0, roomHeight, zCenter); scene.add(ceiling);
            }
            if (i === 0) {
                createBox(0, roomHeight/2, zCenter + roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom);
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, isDarkRoom);
            } else if (i === roomsCount - 1) {
                createBox(0, roomHeight/2, zCenter - roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom);
                const darkCeiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkWallMat);
                darkCeiling.rotation.x = Math.PI / 2; darkCeiling.position.set(0, roomHeight, zCenter); scene.add(darkCeiling);
                benchPosition.set(0, 0.4, zCenter);
                createBox(0, 0.4, zCenter, 3.5, 0.8, 1.5, true, false, benchMat);
            } else {
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, false);
            }
            if (!isDarkRoom) {
                if (i === 0) { createHangingTV(0, zCenter, roomHeight, 0); } 
                else if (i === 1) { loadAllModels(0, zCenter); createHangingModel7(0, zCenter, roomHeight); } 
                else if (i === 2) { createScaffoldingStructure(0, zCenter, i); } 
                else { let rotation = Math.random() * Math.PI; createHangingTV(0, zCenter, roomHeight, rotation); }
                
                const standardW = 2.6; const standardH = 3.25; 
                const postersPerSide = 6; const sideSpacing = 3.0; 
                const sideWallLength = postersPerSide * sideSpacing;
                const startZ = zCenter + (sideWallLength / 2) - (sideSpacing / 2); 
                for (let k = 0; k < postersPerSide; k++) {
                    const zPos = startZ - (k * sideSpacing);
                    addPoster(-9.7, 2.7, zPos, Math.PI/2, standardW, standardH, i);
                    addPoster(9.7, 2.7, zPos, -Math.PI/2, standardW, standardH, i);
                }
                const offsetX = 6.0; const offsetZ = 0.3; 
                addPoster(-offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                addPoster(offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                if (i > 0) { 
                   addPoster(-offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                   addPoster(offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                }
            } else {
                const projW = 9.0; const projH = 5.06;
                const wallDist = (roomSize/2) - 0.4;
                createProjection(-wallDist, 3, zCenter, projW, projH, Math.PI/2, videoTex1);
                createProjection(wallDist, 3, zCenter, projW, projH, -Math.PI/2, videoTex1);
                createProjection(0, 3, zCenter - wallDist, projW, projH, 0, videoTex1);
            }
        }

        const followerTex = textureLoader.load('assets/gerb.png', undefined, undefined, (err) => console.error("Missing gerb.png"));
        followerTex.colorSpace = THREE.SRGBColorSpace;
        const followerGeo = new THREE.PlaneGeometry(3, 3);
        const followerMat = new THREE.MeshBasicMaterial({ map: followerTex, side: THREE.DoubleSide, transparent: true });
        const follower = new THREE.Mesh(followerGeo, followerMat);
        follower.position.set(0, 2.5, 0); scene.add(follower);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);
        
        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); 
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- УПРАВЛІННЯ ---
        const controls = new PointerLockControls(camera, document.body);
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const sitHint = document.getElementById('sit-hint');
        const mobileSitBtn = document.getElementById('mobile-sit-btn');
        const modal = document.getElementById('artwork-modal');
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        const cursor = document.getElementById('cursor');

        let isModalOpen = false;
        let isSitting = false;
        let isGameActive = false;

        function checkRoomLoad(roomIndex) {
            loadRoomTextures(roomIndex);
            loadRoomTextures(roomIndex + 1); 
        }

        function startGame(e) {
            e.preventDefault(); e.stopPropagation();
            startScreen.style.display = 'none';
            isGameActive = true;
            
            bgMusic.play().catch(e => console.log("Audio block", e));
            video1.play().catch(e => console.log("Video1 block", e));
            video2.play().catch(e => console.log("Video2 block", e));

            if (!isMobile) {
                controls.lock();
                checkRoomLoad(0); 
            } else {
                checkRoomLoad(0);
            }
        }

        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', startGame);

        // --- NEW FLOATING JOYSTICK LOGIC ---
        const joyLeft = { active: false, startX: 0, startY: 0, moveX: 0, moveY: 0, el: document.getElementById('joy-left'), knob: document.getElementById('joy-left').querySelector('.joystick-knob') };
        const joyRight = { active: false, startX: 0, startY: 0, deltaX: 0, deltaY: 0, el: document.getElementById('joy-right'), knob: document.getElementById('joy-right').querySelector('.joystick-knob') };

        if(isMobile) {
            function handleTouch(e, type) {
                if (!isGameActive) return;
                if (e.target.id === 'mobile-sit-btn' || e.target.id === 'artwork-modal' || e.target.closest('#artwork-modal')) return;

                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const x = t.clientX;
                    const y = t.clientY;

                    // START
                    if (type === 'start') {
                        // LEFT ZONE (Movement)
                        if (!joyLeft.active && x < window.innerWidth / 2) {
                            joyLeft.active = true; joyLeft.id = t.identifier;
                            joyLeft.startX = x; joyLeft.startY = y;
                            joyLeft.el.style.display = 'block';
                            joyLeft.el.style.left = x + 'px'; joyLeft.el.style.top = y + 'px';
                            joyLeft.knob.style.transform = `translate(-50%, -50%)`;
                        }
                        // RIGHT ZONE (Look)
                        else if (!joyRight.active && x > window.innerWidth / 2) {
                            joyRight.active = true; joyRight.id = t.identifier;
                            joyRight.startX = x; joyRight.startY = y;
                            joyRight.el.style.display = 'block';
                            joyRight.el.style.left = x + 'px'; joyRight.el.style.top = y + 'px';
                            joyRight.knob.style.transform = `translate(-50%, -50%)`;
                        }
                    }

                    // MOVE
                    if (type === 'move') {
                        if (joyLeft.active && t.identifier === joyLeft.id) {
                            const dx = x - joyLeft.startX;
                            const dy = y - joyLeft.startY;
                            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                            const angle = Math.atan2(dy, dx);
                            joyLeft.moveX = (Math.cos(angle) * dist) / 50; 
                            joyLeft.moveY = (Math.sin(angle) * dist) / 50;
                            joyLeft.knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                        }
                        if (joyRight.active && t.identifier === joyRight.id) {
                            const dx = x - joyRight.startX;
                            const dy = y - joyRight.startY;
                            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                            const angle = Math.atan2(dy, dx);
                            // Smooth visual update for right stick
                            joyRight.knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                            
                            // Rotation Delta
                            joyRight.deltaX = (x - joyRight.startX) * 0.005;
                            joyRight.deltaY = (y - joyRight.startY) * 0.005;
                            // Reset start to continuous scrolling feel, or keep absolute? 
                            // Let's keep absolute from start touch for smoother feeling
                        }
                    }

                    // END
                    if (type === 'end') {
                        if (joyLeft.active && t.identifier === joyLeft.id) {
                            joyLeft.active = false; joyLeft.moveX = 0; joyLeft.moveY = 0; joyLeft.el.style.display = 'none';
                        }
                        if (joyRight.active && t.identifier === joyRight.id) {
                            joyRight.active = false; joyRight.deltaX = 0; joyRight.deltaY = 0; joyRight.el.style.display = 'none';
                        }
                    }
                }
            }
            document.addEventListener('touchstart', e => handleTouch(e, 'start'), {passive: false});
            document.addEventListener('touchmove', e => handleTouch(e, 'move'), {passive: false});
            document.addEventListener('touchend', e => handleTouch(e, 'end'));
            
            document.addEventListener('click', () => {
                if (isGameActive && !isModalOpen) checkIntersectionAndClick();
                if (isModalOpen) closeModal();
            });
            
            mobileSitBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSit(); });
        } else {
            document.addEventListener('click', () => {
                if (isGameActive) {
                    if (isModalOpen) closeModal();
                    else { if (controls.isLocked) checkIntersectionAndClick(); else controls.lock(); }
                }
            });
        }

        function checkIntersectionAndClick() {
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(postersArray);
            if (intersects.length > 0 && intersects[0].distance < 6) openModal(intersects[0].object.userData);
        }

        function openModal(data) {
            isModalOpen = true; 
            if (!isMobile) controls.unlock();
            const imgEl = document.getElementById('modal-img');
            imgEl.src = data.url; 
            document.getElementById('modal-title').innerText = data.title;
            document.getElementById('modal-desc').innerText = `${data.year} • ${data.desc}`;
            modal.style.display = 'flex';
        }

        function closeModal() { 
            isModalOpen = false; modal.style.display = 'none'; 
            if (!isMobile) controls.lock(); 
        }

        function toggleSit() {
            if (isSitting) { 
                isSitting = false; camera.position.y = 1.7; camera.fov = 70; camera.updateProjectionMatrix();
                bgMusic.volume = 0.5;
                if(video1) video1.muted = true;
                if(isMobile) mobileSitBtn.style.display = 'none';
            } else {
                const dist = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (dist < 5.0) {
                    isSitting = true; 
                    camera.position.set(benchPosition.x, benchPosition.y + 1.2, benchPosition.z); 
                    velocity.set(0, 0, 0);
                    camera.lookAt(0, 3, benchPosition.z + 20); 
                    camera.fov = 40; camera.updateProjectionMatrix();
                    bgMusic.volume = 0.05;
                    if(video1) { video1.muted = false; video1.volume = 1.0; }
                    if(isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "UP"; }
                }
            }
        }

        const move = { f: false, b: false, l: false, r: false, shift: false };
        const velocity = new THREE.Vector3();
        let canJump = false;

        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') move.f = true;
            if(e.code === 'KeyS') move.b = true;
            if(e.code === 'KeyA') move.l = true;
            if(e.code === 'KeyD') move.r = true;
            if(e.code === 'ShiftLeft') move.shift = true;
            if(e.code === 'Space' && canJump && !isSitting) { velocity.y += 12; canJump = false; }
            if(e.code === 'KeyC') toggleSit();
        });

        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') move.f = false;
            if(e.code === 'KeyS') move.b = false;
            if(e.code === 'KeyA') move.l = false;
            if(e.code === 'KeyD') move.r = false;
            if(e.code === 'ShiftLeft') move.shift = false;
        });

        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const time = performance.now(); const delta = (time - prevTime) / 1000;
            if (revolvingStage) { revolvingStage.rotation.y += 0.1 * delta; }
            animatedModels.forEach(model => { model.rotation.y -= 1.0 * delta; });
            
            if (follower) {
                follower.lookAt(camera.position);
                if (follower.position.distanceTo(camera.position) > 3.0) {
                    const direction = new THREE.Vector3().subVectors(camera.position, follower.position).normalize();
                    follower.position.add(direction.multiplyScalar(2.5 * delta));
                    follower.position.y = 2.5;
                }
            }

            if (!isSitting) {
                const distToBench = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (distToBench < 5.0) { if (isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "SIT"; } else { sitHint.style.display = 'block'; } } 
                else { sitHint.style.display = 'none'; if (isMobile && !isSitting) mobileSitBtn.style.display = 'none'; }
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 30.0 * delta; 
                const speed = (move.shift ? 150 : 80);
                const direction = new THREE.Vector3();
                if (isMobile) {
                    // Mobile Inputs from Floating Joystick
                    if (joyLeft.active) { 
                        // joyLeft.moveY is -1 (forward) to 1 (back)
                        direction.z = joyLeft.moveY; 
                        direction.x = joyLeft.moveX; 
                    }
                    if (joyRight.active) { 
                        // Use raw delta for rotation speed
                        camera.rotation.y -= joyRight.deltaX * 100 * delta; 
                    }
                } else {
                    direction.z = Number(move.f) - Number(move.b);
                    direction.x = Number(move.r) - Number(move.l);
                }
                direction.normalize();
                if (isMobile) {
                     if (joyLeft.active) {
                         const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
                         const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();
                         velocity.x += (right.x * joyLeft.moveX + forward.x * joyLeft.moveY) * speed * delta;
                         velocity.z += (right.z * joyLeft.moveX + forward.z * joyLeft.moveY) * speed * delta;
                     }
                } else {
                    if (move.f || move.b) velocity.z -= direction.z * speed * delta;
                    if (move.l || move.r) velocity.x -= direction.x * speed * delta;
                    controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
                }
                if(isMobile) { camera.position.add(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); }
                camera.position.y += velocity.y * delta;
                if (camera.position.y < 1.7) { velocity.y = 0; camera.position.y = 1.7; canJump = true; }
                const pPos = camera.position;
                const pBox = new THREE.Box3(new THREE.Vector3(pPos.x-0.4, pPos.y-1, pPos.z-0.4), new THREE.Vector3(pPos.x+0.4, pPos.y+1, pPos.z+0.4));
                let hit = false;
                for(let obj of collidableObjects) {
                    if (obj.box && pBox.intersectsBox(obj.box)) hit = true;
                    if (obj.customType === 'cylinder') {
                        const dist = Math.sqrt(Math.pow(pPos.x - obj.position.x, 2) + Math.pow(pPos.z - obj.position.z, 2));
                        if (dist < obj.radius) hit = true;
                    }
                }
                if(hit) { 
                    if(isMobile) { camera.position.sub(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); } 
                    else { controls.moveForward(velocity.z * delta); controls.moveRight(velocity.x * delta); }
                }
                
                const currentRoom = Math.max(0, Math.round(-camera.position.z / 20));
                checkRoomLoad(currentRoom);

            } else { sitHint.style.display = 'none'; velocity.set(0,0,0); }
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(postersArray);
            if (intersects.length > 0 && intersects[0].distance < 6) cursor.classList.add('hover-active'); else cursor.classList.remove('hover-active');
            prevTime = time;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Olympia Gallery - Lazy Load</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s;
        }
        #loading-text { font-size: 1.2rem; margin-bottom: 20px; letter-spacing: 2px; }
        #progress-bar { width: 200px; height: 4px; background: #333; border-radius: 2px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #fff; transition: width 0.2s; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 50;
            display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center; backdrop-filter: blur(5px);
        }
        
        #start-btn {
            margin-top: 30px; padding: 20px 60px; font-size: 1.2rem; font-weight: bold;
            color: black; background: white; border: none; border-radius: 50px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: transform 0.2s; z-index: 51; box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #start-btn:active { transform: scale(0.95); background: #ffff00; }

        #instructions { margin-top: 20px; color: #aaa; font-size: 0.9rem; line-height: 1.6; max-width: 85%; }
        .key { display: inline-block; border: 1px solid #777; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; color: #fff; }

        #cursor {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: white;
            border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.8; pointer-events: none; mix-blend-mode: difference;
            z-index: 5; transition: transform 0.15s;
        }
        .hover-active { transform: translate(-50%, -50%) scale(2.0) !important; background: #00ff66 !important; }

        #sit-hint {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            color: white; background: rgba(0,0,0,0.6); padding: 10px 20px;
            border-radius: 20px; font-size: 0.9rem; display: none; pointer-events: none; z-index: 20;
        }
        
        /* MOBILE JOYS */
        .joystick-zone {
            position: absolute; bottom: 30px; width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.05); border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.15);
            display: none; z-index: 40; touch-action: none;
        }
        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        .stick-knob {
            position: absolute; top: 50%; left: 50%; width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.3); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        
        #artwork-modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.98); z-index: 60;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; cursor: pointer; color: white;
        }
        #modal-img { max-height: 80vh; max-width: 95%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin-bottom: 20px; object-fit: contain; }
        #modal-info { max-width: 600px; padding: 0 20px; }
        #modal-title { font-weight: 800; font-size: 1.5rem; margin: 0 0 5px 0; text-transform: uppercase; }
        
        #mobile-sit-btn {
            position: absolute; right: 40px; bottom: 190px; 
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid white;
            color: white; font-weight: bold; display: none; z-index: 45;
            align-items: center; justify-content: center; cursor: pointer;
            backdrop-filter: blur(5px);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="cursor"></div>
    <div id="sit-hint">Натисни <span class="key">C</span> щоб сісти</div>
    
    <div id="loading-screen">
        <div id="loading-text">ЗАВАНТАЖЕННЯ...</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="start-screen">
        <h1>EXHIBITION 2025</h1>
        <div id="instructions">
            <p>ПК: <span class="key">WASD</span> рух &nbsp; <span class="key">C</span> сісти</p>
            <p>Мобільний: Джойстики на екрані</p>
            <p style="color: #aaa; font-size: 0.8em; margin-top:10px;">(Постери вантажаться по ходу руху)</p>
        </div>
        <button id="start-btn" type="button">УВІЙТИ</button>
    </div>

    <div id="stick-left" class="joystick-zone"><div class="stick-knob"></div></div>
    <div id="stick-right" class="joystick-zone"><div class="stick-knob"></div></div>
    <div id="mobile-sit-btn">SIT</div>

    <audio id="bgMusic" loop preload="auto">
        <source src="assets/song.mp3" type="audio/mpeg">
    </audio>

    <video id="video1" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video1.mp4" type="video/mp4">
    </video>
    <video id="video2" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video2.mp4" type="video/mp4">
    </video>

    <div id="artwork-modal">
        <img id="modal-img" src="" alt="Artwork">
        <div id="modal-info">
            <div id="modal-title">TITLE</div>
            <p id="modal-desc">Description</p>
            <p style="font-size: 0.8rem; margin-top: 20px; color: #888;">TAP TO CLOSE</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- MANAGER ---
        const manager = new THREE.LoadingManager();
        manager.onProgress = function (item, loaded, total) {
            const percent = (loaded / total) * 100;
            document.getElementById('progress-fill').style.width = percent + '%';
        };
        manager.onLoad = function () {
            document.getElementById('loading-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
                
                // Якщо мобільний - завантажуємо першу кімнату одразу
                if(isMobile) checkRoomLoad(0);
            }, 500);
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.Fog(0xffffff, 5, 50); 

        RectAreaLightUniformsLib.init();

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.7, 8); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        if (isMobile) {
            renderer.shadowMap.enabled = false; 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
        } else {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
        }
        
        document.body.appendChild(renderer.domElement);

        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.5;

        // --- ЛІНИВЕ ЗАВАНТАЖЕННЯ (SYSTEM) ---
        // Тут ми будемо зберігати посилання на меші постерів, які треба завантажити
        // Структура: { 0: [{mesh, url}, ...], 1: [...] } де ключ - номер кімнати
        const pendingPosters = {}; 
        const roomsLoaded = {}; // Щоб знати, які кімнати вже завантажені

        // Допоміжний лоадер для Lazy Load
        const lazyLoader = new THREE.TextureLoader();

        // Функція, яка завантажує текстури для конкретної кімнати
        function loadRoomTextures(roomIndex) {
            if (roomsLoaded[roomIndex]) return; // Вже готово
            if (!pendingPosters[roomIndex]) return; // Нема постерів

            // console.log(`Lazy loading room ${roomIndex}...`);
            roomsLoaded[roomIndex] = true;

            const items = pendingPosters[roomIndex];
            items.forEach(item => {
                lazyLoader.load(item.url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    // Створюємо новий матеріал з текстурою
                    const newMat = new THREE.MeshStandardMaterial({ 
                        map: tex, 
                        color: 0xffffff, 
                        roughness: 0.4 
                    });
                    item.mesh.material = newMat;
                    item.mesh.material.needsUpdate = true;
                }, undefined, (err) => {
                    // Якщо jpg нема, пробуємо png (fallback)
                    const pngUrl = item.url.replace('small/', '').replace('.jpg', '.png');
                    lazyLoader.load(pngUrl, (tex2)=>{
                        tex2.colorSpace = THREE.SRGBColorSpace;
                        const newMat = new THREE.MeshStandardMaterial({ map: tex2, color: 0xffffff, roughness: 0.4 });
                        item.mesh.material = newMat;
                    });
                });
            });
        }

        // --- 2. МАТЕРІАЛИ ---
        const textureLoader = new THREE.TextureLoader(manager);
        const concreteTex = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/plaster_grey_04/plaster_grey_04_diff_1k.jpg');
        concreteTex.wrapS = concreteTex.wrapT = THREE.RepeatWrapping;
        concreteTex.repeat.set(10, 40); concreteTex.colorSpace = THREE.SRGBColorSpace;

        const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const floorMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
        const darkWallMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
        const darkFloorMat = new THREE.MeshStandardMaterial({ color: 0x020202, roughness: 0.9 });
        const tvFrameMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const cableMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const benchMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.3 });
        const mobilePosterMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6, metalness: 0.1 });

        const video1 = document.getElementById('video1');
        const video2 = document.getElementById('video2');
        let videoTex1 = new THREE.VideoTexture(video1);
        let videoTex2 = new THREE.VideoTexture(video2);
        videoTex1.colorSpace = THREE.SRGBColorSpace;
        videoTex2.colorSpace = THREE.SRGBColorSpace;

        const collidableObjects = []; 
        const postersArray = []; 
        let posterIdx = 0;
        let revolvingStage = null;
        const animatedModels = [];

        let currentImageId = 1;
        const totalImages = 65; 

        function getNextImage() {
            const id = currentImageId;
            const smallUrl = `assets/small/image${id}.jpg`;
            const fullUrl = `assets/image${id}.png`; 
            const title = `Artwork #${id}`;
            currentImageId++; 
            if (currentImageId > totalImages) currentImageId = 1; 
            return { smallUrl, fullUrl, title, id };
        }

        // --- 3. ФУНКЦІЇ БУДІВНИЦТВА ---
        
        // Змінив сигнатуру: додано roomIndex
        function addPoster(x, y, z, ry, w, h, roomIndex) {
            const data = getNextImage();
            const geo = new THREE.PlaneGeometry(w, h);
            
            let mesh;

            if (isMobile) {
                // МОБІЛЬНИЙ: Ставимо сіру заглушку
                mesh = new THREE.Mesh(geo, mobilePosterMat);
                
                // Додаємо в чергу на завантаження для цієї кімнати
                if (!pendingPosters[roomIndex]) pendingPosters[roomIndex] = [];
                pendingPosters[roomIndex].push({ mesh: mesh, url: data.smallUrl });
            } else {
                // ПК: Вантажимо одразу
                const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 }); 
                mesh = new THREE.Mesh(geo, mat);
                textureLoader.load(data.smallUrl, (tex) => { 
                    tex.colorSpace = THREE.SRGBColorSpace; mat.map = tex; mat.needsUpdate = true; 
                }, undefined, (err) => {
                    textureLoader.load(data.fullUrl, (ft) => { ft.colorSpace = THREE.SRGBColorSpace; mat.map = ft; mat.needsUpdate = true; });
                });
            }

            mesh.position.set(x, y, z); mesh.rotation.y = ry;
            mesh.userData = { isPoster: true, url: data.fullUrl, title: data.title, year: "2025", desc: "Collection" };
            scene.add(mesh); postersArray.push(mesh); 
        }

        function createBox(x, y, z, w, h, d, isWall = true, isDark = false, customMat = null) {
            let mat = customMat ? customMat : (isDark ? (isWall ? darkWallMat : darkFloorMat) : (isWall ? wallMat : floorMat));
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z); 
            mesh.receiveShadow = !isMobile;
            if(isWall) {
                mesh.castShadow = (!isMobile && !isDark); 
                mesh.updateMatrixWorld();
                collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) });
            }
            scene.add(mesh);
        }

        function createDoorWall(z, width, height, isDark = false) {
            const doorW = 4, doorH = 3.5, sideW = (width - doorW) / 2, thick = 0.5;
            createBox(-(width/2) + (sideW/2), height/2, z, sideW, height, thick, true, isDark);
            createBox((width/2) - (sideW/2), height/2, z, sideW, height, thick, true, isDark);
            createBox(0, doorH + (height-doorH)/2, z, doorW, height-doorH, thick, true, isDark);
        }

        function createHangingTV(x, z, ceilingHeight, rotationY = 0) {
            const tvW = 1.78; const tvH = 3.16; const tvD = 0.1;
            const tvGeo = new THREE.BoxGeometry(tvW, tvH, tvD);
            const screenMat = new THREE.MeshBasicMaterial({ map: videoTex2 });
            const materials = [tvFrameMat, tvFrameMat, tvFrameMat, tvFrameMat, screenMat, tvFrameMat];
            const tv = new THREE.Mesh(tvGeo, materials);
            const tvY = 3.0; 
            tv.position.set(x, tvY, z); tv.rotation.y = rotationY; scene.add(tv);
            const tvTopY = tvY + (tvH / 2);
            const cableLen = ceilingHeight - tvTopY;
            const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen > 0 ? cableLen : 0.1);
            cableGeo.translate(0, cableLen / 2, 0); 
            const c1 = new THREE.Mesh(cableGeo, cableMat); c1.position.set(-tvW*0.3, tvH/2, 0); tv.add(c1);
            const c2 = new THREE.Mesh(cableGeo, cableMat); c2.position.set(tvW*0.3, tvH/2, 0); tv.add(c2);
            if (!isMobile) {
                const screenLight = new THREE.PointLight(0xffffff, 8, 7);
                screenLight.position.set(0, 0, 1.0); tv.add(screenLight);
            }
            tv.userData.isObstacle = true; 
            collidableObjects.push({ customType: 'cylinder', mesh: tv, radius: 0.4, position: tv.position });
        }

        function createProjection(x, y, z, w, h, rotationY, texture) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
            mesh.position.set(x, y, z); mesh.rotation.y = rotationY; scene.add(mesh);
            if(!isMobile) {
                const light = new THREE.PointLight(0xaaaaff, 30, 25);
                light.position.set(x + Math.sin(rotationY), y, z + Math.cos(rotationY));
                scene.add(light);
            }
        }

        function createScaffoldingStructure(x, z, roomIndex) {
            revolvingStage = new THREE.Group();
            revolvingStage.position.set(x, 0, z);
            const platform = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.5 }));
            platform.position.y = 0.1; platform.receiveShadow = !isMobile; revolvingStage.add(platform);
            collidableObjects.push({ box: new THREE.Box3().setFromObject(platform) }); 
            const structureGroup = new THREE.Group(); structureGroup.position.y = 0.2; 
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
            const w = 4; const h = 3.5; const d = 4; const r = 0.05;
            function addPipe(px, py, pz, height, axis) {
                const mesh = new THREE.Mesh(new THREE.CylinderGeometry(r, r, height), metalMat);
                mesh.position.set(px, py, pz);
                if (axis === 'z') mesh.rotation.x = Math.PI / 2;
                if (axis === 'x') mesh.rotation.z = Math.PI / 2;
                mesh.castShadow = !isMobile; structureGroup.add(mesh);
                collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) });
            }
            function addJoint(jx, jy, jz) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(r * 1.8), metalMat);
                mesh.position.set(jx, jy, jz); structureGroup.add(mesh);
            }
            addPipe(-w/2, h/2, -d/2, h, 'y'); addPipe(w/2, h/2, -d/2, h, 'y');
            addPipe(-w/2, h/2, d/2, h, 'y'); addPipe(w/2, h/2, d/2, h, 'y');
            const levels = [0.2, h - 0.2];
            levels.forEach(lev => {
                addPipe(0, lev, -d/2, w, 'x'); addPipe(0, lev, d/2, w, 'x');
                addPipe(-w/2, lev, 0, d, 'z'); addPipe(w/2, lev, 0, d, 'z');
            });
            const cornersX = [-w/2, w/2]; const cornersZ = [-d/2, d/2];
            levels.forEach(lev => { cornersX.forEach(cx => { cornersZ.forEach(cz => { addJoint(cx, lev, cz); }); }); });
            
            function mountPoster(px, py, pz, ry, width, height, pipeYLevel) {
                const data = getNextImage();
                let mesh;
                if(isMobile) {
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.5), mobilePosterMat);
                    if (!pendingPosters[roomIndex]) pendingPosters[roomIndex] = [];
                    pendingPosters[roomIndex].push({ mesh: mesh, url: data.smallUrl });
                } else {
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.5 });
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.5), mat);
                    textureLoader.load(data.smallUrl, (t)=>{t.colorSpace=THREE.SRGBColorSpace; mat.map=t; mat.needsUpdate=true;}, undefined, (e)=>{
                        textureLoader.load(data.fullUrl, (ft)=>{ft.colorSpace=THREE.SRGBColorSpace; mat.map=ft; mat.needsUpdate=true;});
                    });
                }

                mesh.position.set(px, py, pz); mesh.rotation.y = ry;
                const stringMat = new THREE.LineBasicMaterial({ color: 0x111111 });
                const pW = 2.0; const pH = 2.5;
                const topOfPosterY = pH / 2; const distToPipe = (pipeYLevel - r) - (py + topOfPosterY);
                const pointsL = [new THREE.Vector3(-pW/2 + 0.15, topOfPosterY, 0), new THREE.Vector3(-pW/2 + 0.15, topOfPosterY + distToPipe, 0)];
                const pointsR = [new THREE.Vector3(pW/2 - 0.15, topOfPosterY, 0), new THREE.Vector3(pW/2 - 0.15, topOfPosterY + distToPipe, 0)];
                mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsL), stringMat));
                mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsR), stringMat));
                mesh.userData = { isPoster: true, url: data.fullUrl, title: data.title, year: "2025", desc: "Mounted Installation" };
                structureGroup.add(mesh); postersArray.push(mesh);
            }
            const topPipeLevel = h - 0.2; const posterCenterY = h / 2;
            mountPoster(0, posterCenterY, d/2, 0, 2, 2.5, topPipeLevel); 
            mountPoster(-w/2, posterCenterY, 0, Math.PI/2, 2, 2.5, topPipeLevel); 
            mountPoster(0, posterCenterY, -d/2, Math.PI, 2.5, 1.8, topPipeLevel); 
            revolvingStage.add(structureGroup); scene.add(revolvingStage);
        }

        const modelFiles = ['output.fbx', 'output2.fbx', 'output3.fbx', 'output4.fbx', 'output5.fbx', 'output6.fbx', 'output9.fbx'];
        function loadAllModels(roomCenterX, roomCenterZ) {
            const fbxLoader = new FBXLoader(manager);
            modelFiles.forEach((filename, index) => {
                const angle = (index / modelFiles.length) * Math.PI * 2;
                const radius = 5; 
                const offsetX = Math.cos(angle) * radius; const offsetZ = Math.sin(angle) * radius;
                const fullPath = `assets/${filename}`;
                fbxLoader.load(fullPath, (object) => {
                    object.scale.set(1, 1, 1); 
                    const box = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let targetScale = 1.0;
                    if (maxDim > 5) { targetScale = 3.0 / maxDim; } else if (maxDim < 0.5) { targetScale = 2.0 / maxDim; }
                    let multiplier = 2.3; 
                    if (filename === 'output3.fbx') { multiplier *= 0.8; }
                    if (filename === 'output9.fbx') { multiplier = (1.9 / 4.0) * 1.4; }
                    if (filename === 'output5.fbx' || filename === 'output6.fbx') { multiplier = 1.9; }
                    targetScale *= multiplier;
                    object.scale.set(targetScale, targetScale, targetScale);
                    object.traverse((child) => { 
                        if (child.isMesh) { 
                            child.castShadow = !isMobile; 
                            child.receiveShadow = !isMobile; 
                        } 
                    });
                    if (filename === 'output3.fbx') { object.rotation.set(0, 0, 0); } else { object.rotation.set(-Math.PI / 2, 0, 0); }
                    if (filename === 'output4.fbx') { animatedModels.push(object); }
                    if (filename === 'output9.fbx') { object.rotation.set(-Math.PI / 2, 0, 0); }
                    object.updateMatrixWorld(); 
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.set(roomCenterX + offsetX, -newBox.min.y, roomCenterZ + offsetZ);
                    scene.add(object);
                    collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                    if (filename === 'output6.fbx') {
                        const loader7 = new FBXLoader();
                        loader7.load('assets/output7.fbx', (obj7) => {
                            const smallScale = targetScale / 4;
                            obj7.scale.set(smallScale, smallScale, smallScale); 
                            obj7.rotation.set(-Math.PI / 2, 0, 0);
                            animatedModels.push(obj7);
                            obj7.traverse((child) => { if (child.isMesh) { child.castShadow = !isMobile; child.receiveShadow = !isMobile; } });
                            const box6 = new THREE.Box3().setFromObject(object);
                            const topY = box6.max.y;
                            obj7.updateMatrixWorld();
                            const box7 = new THREE.Box3().setFromObject(obj7);
                            const heightOffset7 = -box7.min.y; 
                            obj7.position.set(object.position.x, topY + 0.05 + heightOffset7, object.position.z);
                            scene.add(obj7);
                        });
                    }
                });
            });
        }

        function createHangingModel8(x, z, roomCeiling) {
            const fbxLoader = new FBXLoader(manager);
            fbxLoader.load('assets/output8.fbx', (object) => {
                object.scale.set(1, 1, 1);
                const box = new THREE.Box3().setFromObject(object);
                const size = new THREE.Vector3(); box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                let targetScale = (maxDim > 5) ? 3.0 / maxDim : (maxDim < 0.5 ? 2.0 / maxDim : 1.0);
                targetScale *= 1.2; 
                object.scale.set(targetScale, targetScale, targetScale);
                object.traverse((child) => { if (child.isMesh) { child.castShadow = !isMobile; child.receiveShadow = !isMobile; } });
                object.rotation.set(-Math.PI/2, 0, 0);
                const hangY = 2.5;
                object.position.set(x, hangY, z);
                scene.add(object);
                collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                const cableLen = roomCeiling - hangY;
                const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen);
                cableGeo.translate(0, cableLen/2, 0);
                const cable = new THREE.Mesh(cableGeo, cableMat);
                cable.position.set(x, hangY, z);
                scene.add(cable);
            });
        }

        // --- 5. ГЕНЕРАЦІЯ СВІТУ ---
        const roomSize = 20; const roomHeight = 6; const roomsCount = 5;
        const whiteFloorL = roomSize * (roomsCount - 1);
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, whiteFloorL), floorMat);
        floor1.rotation.x = -Math.PI / 2; floor1.position.z = -whiteFloorL / 2 + roomSize / 2; floor1.receiveShadow = !isMobile; scene.add(floor1);
        const zLastRoom = -((roomsCount - 1) * roomSize);
        let benchPosition = new THREE.Vector3(0, 0, 0); 
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkFloorMat);
        floor2.rotation.x = -Math.PI / 2; floor2.position.z = zLastRoom; scene.add(floor2);

        for (let i = 0; i < roomsCount; i++) {
            const zCenter = -(i * roomSize);
            const isDarkRoom = (i === roomsCount - 1);
            if (!isDarkRoom && !isMobile) {
                const rectLightLeft = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                rectLightLeft.position.set(-8, 5.5, zCenter); rectLightLeft.lookAt(-20, 1, zCenter); scene.add(rectLightLeft);
                const rectLightRight = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                rectLightRight.position.set(8, 5.5, zCenter); rectLightRight.lookAt(20, 1, zCenter); scene.add(rectLightRight);
                const fillLight = new THREE.PointLight(0xffffff, 2, 20); fillLight.position.set(0, 5, zCenter); scene.add(fillLight);
            }
            else if (!isDarkRoom && isMobile) {
                 const simpleLight = new THREE.PointLight(0xffffff, 1.5, 15);
                 simpleLight.position.set(0, 4, zCenter); scene.add(simpleLight);
            }

            createBox(-roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom); 
            createBox(roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom); 
            if (!isDarkRoom) {
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), wallMat);
                ceiling.rotation.x = Math.PI / 2; ceiling.position.set(0, roomHeight, zCenter); scene.add(ceiling);
            }
            if (i === 0) {
                createBox(0, roomHeight/2, zCenter + roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom);
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, isDarkRoom);
            } else if (i === roomsCount - 1) {
                createBox(0, roomHeight/2, zCenter - roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom);
                const darkCeiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkWallMat);
                darkCeiling.rotation.x = Math.PI / 2; darkCeiling.position.set(0, roomHeight, zCenter); scene.add(darkCeiling);
                benchPosition.set(0, 0.4, zCenter);
                createBox(0, 0.4, zCenter, 3.5, 0.8, 1.5, true, false, benchMat);
            } else {
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, false);
            }
            if (!isDarkRoom) {
                if (i === 0) { createHangingTV(0, zCenter, roomHeight, 0); } 
                else if (i === 1) { loadAllModels(0, zCenter); createHangingModel8(0, zCenter, roomHeight); } 
                else if (i === 2) { createScaffoldingStructure(0, zCenter, i); } 
                else { let rotation = Math.random() * Math.PI; createHangingTV(0, zCenter, roomHeight, rotation); }
                
                const standardW = 2.6; const standardH = 3.25; 
                const postersPerSide = 6; const sideSpacing = 3.0; 
                const sideWallLength = postersPerSide * sideSpacing;
                const startZ = zCenter + (sideWallLength / 2) - (sideSpacing / 2); 
                for (let k = 0; k < postersPerSide; k++) {
                    const zPos = startZ - (k * sideSpacing);
                    addPoster(-9.7, 2.7, zPos, Math.PI/2, standardW, standardH, i);
                    addPoster(9.7, 2.7, zPos, -Math.PI/2, standardW, standardH, i);
                }
                const offsetX = 6.0; const offsetZ = 0.3; 
                addPoster(-offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                addPoster(offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                if (i > 0) { 
                   addPoster(-offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                   addPoster(offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                }
            } else {
                const projW = 9.0; const projH = 5.06;
                const wallDist = (roomSize/2) - 0.4;
                createProjection(-wallDist, 3, zCenter, projW, projH, Math.PI/2, videoTex1);
                createProjection(wallDist, 3, zCenter, projW, projH, -Math.PI/2, videoTex1);
                createProjection(0, 3, zCenter - wallDist, projW, projH, 0, videoTex1);
            }
        }

        const followerTex = textureLoader.load('assets/gerb.png', undefined, undefined, (err) => console.error("Missing gerb.png"));
        followerTex.colorSpace = THREE.SRGBColorSpace;
        const followerGeo = new THREE.PlaneGeometry(3, 3);
        const followerMat = new THREE.MeshBasicMaterial({ map: followerTex, side: THREE.DoubleSide, transparent: true });
        const follower = new THREE.Mesh(followerGeo, followerMat);
        follower.position.set(0, 2.5, 0); scene.add(follower);
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); scene.add(ambientLight);

        // --- УПРАВЛІННЯ ---
        const controls = new PointerLockControls(camera, document.body);
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const sitHint = document.getElementById('sit-hint');
        const mobileSitBtn = document.getElementById('mobile-sit-btn');
        const modal = document.getElementById('artwork-modal');
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        const cursor = document.getElementById('cursor');

        let isModalOpen = false;
        let isSitting = false;
        let isGameActive = false;

        // ЛОГІКА ПЕРЕВІРКИ КІМНАТИ
        function checkRoomLoad(roomIndex) {
            loadRoomTextures(roomIndex);
            loadRoomTextures(roomIndex + 1); // Preload next
        }

        // ВМИКАННЯ ГРИ
        function startGame(e) {
            e.preventDefault();
            e.stopPropagation();
            startScreen.style.display = 'none';
            isGameActive = true;
            
            // Намагаємось запустити все медіа
            bgMusic.play().catch(e => console.log("Audio block", e));
            video1.play().catch(e => console.log("Video1 block", e));
            video2.play().catch(e => console.log("Video2 block", e));

            if (!isMobile) {
                controls.lock();
            } else {
                document.getElementById('stick-left').style.display = 'block';
                document.getElementById('stick-right').style.display = 'block';
                checkRoomLoad(0);
            }
        }

        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', startGame);

        // Мобільне керування (Touch)
        const joystickL = { active: false, id: null, startX: 0, startY: 0, moveX: 0, moveY: 0 };
        const joystickR = { active: false, id: null, startX: 0, startY: 0, deltaX: 0, deltaY: 0 };
        const stickL = document.getElementById('stick-left');
        const stickR = document.getElementById('stick-right');
        const knobL = stickL.querySelector('.stick-knob');
        const knobR = stickR.querySelector('.stick-knob');

        if(isMobile) {
            function handleTouch(e, type) {
                if (!isGameActive) return;
                if (e.target.id === 'mobile-sit-btn' || e.target.id === 'artwork-modal' || e.target.closest('#artwork-modal')) return;

                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (type === 'start' && !joystickL.active && t.clientX < window.innerWidth / 2) {
                        joystickL.active = true; joystickL.id = t.identifier;
                        joystickL.startX = t.clientX; joystickL.startY = t.clientY;
                        stickL.style.left = (t.clientX - 60) + 'px';
                        stickL.style.bottom = (window.innerHeight - t.clientY - 60) + 'px';
                        knobL.style.transform = `translate(-50%, -50%)`;
                    }
                    if (joystickL.active && t.identifier === joystickL.id) {
                        if (type === 'move') {
                            const dx = t.clientX - joystickL.startX;
                            const dy = t.clientY - joystickL.startY;
                            const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                            const angle = Math.atan2(dy, dx);
                            joystickL.moveX = (Math.cos(angle) * dist) / 50; 
                            joystickL.moveY = (Math.sin(angle) * dist) / 50;
                            knobL.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                        } else if (type === 'end') {
                            joystickL.active = false; joystickL.moveX = 0; joystickL.moveY = 0;
                            knobL.style.transform = `translate(-50%, -50%)`;
                            stickL.style.left = '20px'; stickL.style.bottom = '30px';
                        }
                    }
                    if (type === 'start' && !joystickR.active && t.clientX > window.innerWidth / 2) {
                        joystickR.active = true; joystickR.id = t.identifier;
                        joystickR.startX = t.clientX; joystickR.startY = t.clientY;
                        stickR.style.right = 'auto'; stickR.style.left = (t.clientX - 60) + 'px';
                        stickR.style.bottom = (window.innerHeight - t.clientY - 60) + 'px';
                    }
                    if (joystickR.active && t.identifier === joystickR.id) {
                        if (type === 'move') {
                            joystickR.deltaX = (t.clientX - joystickR.startX) * 0.005;
                            joystickR.deltaY = (t.clientY - joystickR.startY) * 0.005;
                            joystickR.startX = t.clientX; joystickR.startY = t.clientY; 
                        } else if (type === 'end') {
                            joystickR.active = false; joystickR.deltaX = 0; joystickR.deltaY = 0;
                            stickR.style.left = 'auto'; stickR.style.right = '20px'; stickR.style.bottom = '30px';
                        }
                    }
                }
            }
            document.addEventListener('touchstart', e => handleTouch(e, 'start'), {passive: false});
            document.addEventListener('touchmove', e => handleTouch(e, 'move'), {passive: false});
            document.addEventListener('touchend', e => handleTouch(e, 'end'));
            
            document.addEventListener('click', () => {
                if (isGameActive && !isModalOpen) checkIntersectionAndClick();
                if (isModalOpen) closeModal();
            });
            
            mobileSitBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSit(); });
        } else {
            document.addEventListener('click', () => {
                if (isGameActive) {
                    if (isModalOpen) closeModal();
                    else { if (controls.isLocked) checkIntersectionAndClick(); else controls.lock(); }
                }
            });
        }

        function checkIntersectionAndClick() {
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(postersArray);
            if (intersects.length > 0 && intersects[0].distance < 6) openModal(intersects[0].object.userData);
        }

        function openModal(data) {
            isModalOpen = true; 
            if (!isMobile) controls.unlock();
            const imgEl = document.getElementById('modal-img');
            imgEl.src = data.url; 
            document.getElementById('modal-title').innerText = data.title;
            document.getElementById('modal-desc').innerText = `${data.year} • ${data.desc}`;
            modal.style.display = 'flex';
        }

        function closeModal() { 
            isModalOpen = false; modal.style.display = 'none'; 
            if (!isMobile) controls.lock(); 
        }

        function toggleSit() {
            if (isSitting) { 
                isSitting = false; camera.position.y = 1.7; camera.fov = 70; camera.updateProjectionMatrix();
                bgMusic.volume = 0.5;
                if(video1) video1.muted = true;
                if(isMobile) mobileSitBtn.style.display = 'none';
            } else {
                const dist = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (dist < 5.0) {
                    isSitting = true; 
                    camera.position.set(benchPosition.x, benchPosition.y + 1.2, benchPosition.z); 
                    velocity.set(0, 0, 0);
                    camera.lookAt(0, 3, benchPosition.z + 20); 
                    camera.fov = 40; camera.updateProjectionMatrix();
                    bgMusic.volume = 0.05;
                    if(video1) { video1.muted = false; video1.volume = 1.0; }
                    if(isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "UP"; }
                }
            }
        }

        const move = { f: false, b: false, l: false, r: false, shift: false };
        const velocity = new THREE.Vector3();
        let canJump = false;

        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') move.f = true;
            if(e.code === 'KeyS') move.b = true;
            if(e.code === 'KeyA') move.l = true;
            if(e.code === 'KeyD') move.r = true;
            if(e.code === 'ShiftLeft') move.shift = true;
            if(e.code === 'Space' && canJump && !isSitting) { velocity.y += 12; canJump = false; }
            if(e.code === 'KeyC') toggleSit();
        });

        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') move.f = false;
            if(e.code === 'KeyS') move.b = false;
            if(e.code === 'KeyA') move.l = false;
            if(e.code === 'KeyD') move.r = false;
            if(e.code === 'ShiftLeft') move.shift = false;
        });

        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const time = performance.now(); const delta = (time - prevTime) / 1000;
            if (revolvingStage) { revolvingStage.rotation.y += 0.1 * delta; }
            animatedModels.forEach(model => { model.rotation.z -= 1.0 * delta; });
            follower.lookAt(camera.position);
            if (follower.position.distanceTo(camera.position) > 3.0) {
                const direction = new THREE.Vector3().subVectors(camera.position, follower.position).normalize();
                follower.position.add(direction.multiplyScalar(2.5 * delta));
                follower.position.y = 2.5;
            }
            if (!isSitting) {
                const distToBench = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (distToBench < 5.0) { if (isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "SIT"; } else { sitHint.style.display = 'block'; } } 
                else { sitHint.style.display = 'none'; if (isMobile && !isSitting) mobileSitBtn.style.display = 'none'; }
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 30.0 * delta; 
                const speed = (move.shift ? 150 : 80);
                const direction = new THREE.Vector3();
                if (isMobile) {
                    if (joystickL.active) { direction.z = joystickL.moveY; direction.x = joystickL.moveX; }
                    if (joystickR.active) { camera.rotation.y -= joystickR.deltaX * 300 * delta; }
                } else {
                    direction.z = Number(move.f) - Number(move.b);
                    direction.x = Number(move.r) - Number(move.l);
                }
                direction.normalize();
                if (isMobile) {
                     if (joystickL.active) {
                         const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
                         const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();
                         velocity.x += (right.x * joystickL.moveX + forward.x * joystickL.moveY) * speed * delta;
                         velocity.z += (right.z * joystickL.moveX + forward.z * joystickL.moveY) * speed * delta;
                     }
                } else {
                    if (move.f || move.b) velocity.z -= direction.z * speed * delta;
                    if (move.l || move.r) velocity.x -= direction.x * speed * delta;
                    controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
                }
                if(isMobile) { camera.position.add(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); }
                camera.position.y += velocity.y * delta;
                if (camera.position.y < 1.7) { velocity.y = 0; camera.position.y = 1.7; canJump = true; }
                const pPos = camera.position;
                const pBox = new THREE.Box3(new THREE.Vector3(pPos.x-0.4, pPos.y-1, pPos.z-0.4), new THREE.Vector3(pPos.x+0.4, pPos.y+1, pPos.z+0.4));
                let hit = false;
                for(let obj of collidableObjects) {
                    if (obj.box && pBox.intersectsBox(obj.box)) hit = true;
                    if (obj.customType === 'cylinder') {
                        const dist = Math.sqrt(Math.pow(pPos.x - obj.position.x, 2) + Math.pow(pPos.z - obj.position.z, 2));
                        if (dist < obj.radius) hit = true;
                    }
                }
                if(hit) { 
                    if(isMobile) { camera.position.sub(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); } 
                    else { controls.moveForward(velocity.z * delta); controls.moveRight(velocity.x * delta); }
                }
                
                // ЛІНИВЕ ЗАВАНТАЖЕННЯ (Check Room)
                if (isMobile) {
                    const currentRoom = Math.max(0, Math.round(-camera.position.z / 20));
                    checkRoomLoad(currentRoom);
                }

            } else { sitHint.style.display = 'none'; velocity.set(0,0,0); }
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(postersArray);
            if (intersects.length > 0 && intersects[0].distance < 6) cursor.classList.add('hover-active'); else cursor.classList.remove('hover-active');
            prevTime = time;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
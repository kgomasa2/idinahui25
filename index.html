<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Іді Нахуй</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* LOADING SCREEN */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #fff; font-family: 'Share Tech Mono', monospace;
            transition: opacity 0.8s ease-out;
        }
        
        #loader-content { width: 80%; max-width: 400px; text-align: center; }
        #loader-title { font-size: 1.2rem; letter-spacing: 4px; margin-bottom: 30px; border-bottom: 1px solid #333; padding-bottom: 10px; display: inline-block; }
        #progress-container { width: 100%; height: 4px; background: #111; position: relative; overflow: hidden; margin-bottom: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #progress-fill { width: 0%; height: 100%; background: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.8); transition: width 0.1s linear; }
        #loader-percent { font-size: 3rem; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }
        #loader-status { font-size: 0.8rem; color: #888; text-transform: uppercase; letter-spacing: 1px; height: 20px; }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 50;
            display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center; backdrop-filter: blur(5px);
            padding: 20px; box-sizing: border-box;
        }
        #start-screen h1 { font-size: 1.8rem; max-width: 100%; line-height: 1.4; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2rem; }
        
        #start-btn {
            margin-top: 30px; padding: 20px 60px; font-size: 1.2rem; font-weight: bold;
            color: black; background: white; border: none; border-radius: 50px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: transform 0.2s; z-index: 51; box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #start-btn:active { transform: scale(0.95); background: #ffff00; }

        #instructions { margin-top: 20px; color: #aaa; font-size: 0.9rem; line-height: 1.6; max-width: 90%; }
        .key { display: inline-block; border: 1px solid #777; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; color: #fff; }

        #cursor {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; background: white;
            border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.8; pointer-events: none; mix-blend-mode: difference;
            z-index: 5; transition: transform 0.15s;
        }
        .hover-active { transform: translate(-50%, -50%) scale(2.0) !important; background: #00ff66 !important; }

        #sit-hint {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            color: white; background: rgba(0,0,0,0.6); padding: 10px 20px;
            border-radius: 20px; font-size: 0.9rem; display: none; pointer-events: none; z-index: 20;
        }
        
        /* Mobile UI Elements */
        .joystick-zone {
            position: absolute; width: 100px; height: 100px; 
            background: rgba(255, 255, 255, 0.1); border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none; z-index: 40; touch-action: none; pointer-events: none;
        }
        .stick-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        
        #mobile-sit-btn {
            position: absolute; right: 20px; bottom: 40px;
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(0, 0, 0, 0.6); border: 2px solid white;
            color: white; font-weight: bold; display: none; z-index: 45;
            align-items: center; justify-content: center; cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }

        #view-btn {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            padding: 10px 25px; border-radius: 25px;
            background: rgba(255, 255, 255, 0.95); color: black;
            font-weight: bold; font-size: 0.9rem; letter-spacing: 1px; white-space: nowrap;
            display: none; z-index: 46; cursor: pointer;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            animation: pulseBtn 2s infinite;
        }
        @keyframes pulseBtn { 0% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.05); } 100% { transform: translateX(-50%) scale(1); } }
        
        #artwork-modal {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.98); z-index: 60;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; color: white;
        }
        #modal-img { max-height: 70vh; max-width: 95%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin-bottom: 20px; object-fit: contain; }
        #modal-info { max-width: 600px; padding: 0 20px; }
        #modal-title { font-weight: 800; font-size: 1.5rem; margin: 0 0 5px 0; text-transform: uppercase; }
        
        #modal-close-btn {
            position: absolute; top: 30px; right: 30px;
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 1px solid white;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; cursor: pointer; pointer-events: auto;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="cursor"></div>
    <div id="sit-hint">Натисни <span class="key">C</span> щоб сісти</div>
    
    <div id="loading-screen">
        <div id="loader-content">
            <div id="loader-title">SYSTEM INITIALIZATION</div>
            <div id="loader-percent">0%</div>
            <div id="progress-container"><div id="progress-fill"></div></div>
            <div id="loader-status">CONNECTING...</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Квартирна виставка артпроєкту "Іді Нахуй"</h1>
        <div id="instructions">
            <p>ПК: <span class="key">WASD</span> рух &nbsp; <span class="key">C</span> сісти</p>
            <p>Мобільний: Лівoруч - Рух, Праворуч - Огляд</p>
        </div>
        <button id="start-btn" type="button">УВІЙТИ</button>
    </div>

    <div id="stick-container" class="joystick-zone"><div class="stick-knob"></div></div>
    <div id="mobile-sit-btn">SIT</div>
    <div id="view-btn">VIEW</div>

    <audio id="bgMusic" loop preload="auto">
        <source src="assets/song.mp3" type="audio/mpeg">
    </audio>

    <video id="video1" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video1.mp4" type="video/mp4">
    </video>
    <video id="video2" loop crossOrigin="anonymous" playsinline style="display:none" muted preload="metadata">
        <source src="assets/video2.mp4" type="video/mp4">
    </video>

    <div id="artwork-modal">
        <div id="modal-close-btn">✕</div>
        <img id="modal-img" src="" alt="Artwork">
        <div id="modal-info">
            <div id="modal-title">TITLE</div>
            <p id="modal-desc">Description</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- LOADING SYSTEM ---
        const loadStartTime = Date.now();
        const minLoadTime = 4500; 
        const loadingStatus = document.getElementById('loader-status');
        const loadingPercent = document.getElementById('loader-percent');
        const loadingFill = document.getElementById('progress-fill');
        
        const statusMessages = [
            "CACHING TEXTURES...", "COMPILING SHADERS...", "INITIALIZING PHYSICS...", 
            "BUILDING GEOMETRY...", "PREPARING ASSETS...", "READY"
        ];
        
        setInterval(() => {
            if(document.getElementById('loading-screen').style.display !== 'none') {
                const txt = statusMessages[Math.floor(Math.random() * (statusMessages.length - 1))];
                loadingStatus.innerText = txt;
            }
        }, 600);

        const manager = new THREE.LoadingManager();
        
        function finishLoading() {
            loadingPercent.innerText = "100%";
            loadingFill.style.width = "100%";
            loadingStatus.innerText = "SYSTEM READY";

            setTimeout(() => {
                const loader = document.getElementById('loading-screen');
                loader.style.opacity = 0;
                setTimeout(() => {
                    loader.style.display = 'none';
                    document.getElementById('start-screen').style.display = 'flex';
                    if (isMobile) checkRoomLoad(0);
                }, 800); 
            }, 500);
        }

        if (isMobile) {
            let simPercent = 0;
            const simInterval = setInterval(() => {
                simPercent += 3;
                if (simPercent > 100) simPercent = 100;
                loadingPercent.innerText = simPercent + '%';
                loadingFill.style.width = simPercent + '%';
                if (simPercent >= 100) {
                    clearInterval(simInterval);
                    finishLoading();
                }
            }, 60);
        } else {
            manager.onProgress = function (item, loaded, total) {
                const rawPercent = (loaded / total) * 100;
                if(!isNaN(rawPercent)) {
                    loadingPercent.innerText = Math.round(rawPercent) + '%';
                    loadingFill.style.width = rawPercent + '%';
                }
            };
            manager.onLoad = function () {
                const currentTime = Date.now();
                const elapsedTime = currentTime - loadStartTime;
                const remainingTime = Math.max(0, minLoadTime - elapsedTime);
                setTimeout(finishLoading, remainingTime);
            };
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.Fog(0xffffff, 5, 50); 

        RectAreaLightUniformsLib.init();

        const aspect = window.innerWidth / window.innerHeight;
        const initialFov = aspect < 1 ? 95 : 70;
        const camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.7, 8); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace; 
        renderer.toneMapping = THREE.NoToneMapping; 
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.5));

        if (isMobile) {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; 
        } else {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        
        document.body.appendChild(renderer.domElement);

        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.65;

        // --- MATERIALS ---
        const textureLoader = isMobile ? new THREE.TextureLoader() : new THREE.TextureLoader(manager);
        const lazyLoader = new THREE.TextureLoader();

        const concreteTex = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/plaster_grey_04/plaster_grey_04_diff_1k.jpg');
        concreteTex.wrapS = concreteTex.wrapT = THREE.RepeatWrapping;
        concreteTex.repeat.set(10, 40); concreteTex.colorSpace = THREE.SRGBColorSpace;

        const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const floorMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
        const darkWallMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.9 });
        const darkFloorMat = new THREE.MeshStandardMaterial({ color: 0x020202, roughness: 0.9 });
        const tvFrameMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
        const cableMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const benchMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.3 });
        const mobilePosterMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6, metalness: 0.1 });
        const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8 });

        const video1 = document.getElementById('video1');
        const video2 = document.getElementById('video2');
        let videoTex1, videoTex2;

        if (isMobile) {
            const cvs = document.createElement('canvas');
            cvs.width = 2; cvs.height = 2;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#050510'; ctx.fillRect(0,0,2,2);
            videoTex1 = new THREE.CanvasTexture(cvs);
            videoTex2 = new THREE.CanvasTexture(cvs);
        } else {
            videoTex1 = new THREE.VideoTexture(video1);
            videoTex2 = new THREE.VideoTexture(video2);
            videoTex1.colorSpace = THREE.SRGBColorSpace;
            videoTex2.colorSpace = THREE.SRGBColorSpace;
        }

        const collidableObjects = []; 
        const postersArray = []; 
        const roomPosters = {}; 
        const roomStatus = {}; 
        const roomGroups = {};

        let revolvingStage = null;
        const animatedModels = [];
        const interactiveObjects = []; 

        let currentImageId = 1;
        const totalImages = 65; 

        function getNextImage() {
            const id = currentImageId;
            let wallUrl;
            if (isMobile) { wallUrl = `assets/small_mobile/image${id}.jpg`; } else { wallUrl = `assets/small/image${id}.jpg`; }
            const fullUrl = `assets/image${id}.png`; 
            const title = `Artwork #${id}`;
            currentImageId++; if (currentImageId > totalImages) currentImageId = 1; 
            return { wallUrl, fullUrl, title, id };
        }

        function addToRoom(object, roomIndex) {
            if (!roomGroups[roomIndex]) {
                roomGroups[roomIndex] = new THREE.Group();
                scene.add(roomGroups[roomIndex]);
            }
            roomGroups[roomIndex].add(object);
        }

        function addPoster(x, y, z, ry, w, h, roomIndex) {
            const data = getNextImage();
            const geo = new THREE.PlaneGeometry(w, h);
            
            let mat;
            
            if (isMobile) {
                mat = placeholderMat.clone();
                if (!roomPosters[roomIndex]) roomPosters[roomIndex] = [];
                roomPosters[roomIndex].push({
                    mesh: null,
                    material: mat,
                    url: data.wallUrl
                });
            } else {
                const tex = textureLoader.load(data.wallUrl, (t) => {
                    t.colorSpace = THREE.SRGBColorSpace;
                }, undefined, (err) => {
                    const pngUrl = data.wallUrl.replace('small/', '').replace('.jpg', '.png');
                    textureLoader.load(pngUrl, (t2)=>{
                        t2.colorSpace = THREE.SRGBColorSpace;
                        mat.map = t2; mat.needsUpdate = true;
                    });
                });
                mat = new THREE.MeshStandardMaterial({ map: tex, color: 0xffffff, roughness: 0.4 });
            }
            
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z); mesh.rotation.y = ry;
            mesh.userData = { type: 'poster', url: data.fullUrl, title: data.title, year: "2025", desc: "Collection" };
            
            addToRoom(mesh, roomIndex);
            postersArray.push(mesh);
            
            if (isMobile && roomPosters[roomIndex]) {
                roomPosters[roomIndex][roomPosters[roomIndex].length - 1].mesh = mesh;
            }
        }

        function checkRoomLoad(currentRoom) {
            if (!isMobile) return;
            // FIX: INCREASE LOADING RANGE FOR LAST ROOMS
            // Load Current, Previous, and TWO steps ahead to prevent grey posters
            const keepLoaded = [currentRoom - 1, currentRoom, currentRoom + 1, currentRoom + 2];
            
            keepLoaded.forEach(idx => {
                if (idx >= 0 && idx < 5 && roomStatus[idx] !== 'loaded') {
                    loadRoomTextures(idx);
                }
            });

            for (let idx = 0; idx < 5; idx++) {
                if (!keepLoaded.includes(idx) && roomStatus[idx] === 'loaded') {
                    unloadRoomTextures(idx);
                }
            }
        }

        function loadRoomTextures(roomIdx) {
            if (!roomPosters[roomIdx]) return;
            roomStatus[roomIdx] = 'loaded';
            roomPosters[roomIdx].forEach(item => {
                lazyLoader.load(item.url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    item.material.map = tex;
                    item.material.color.setHex(0xffffff); 
                    item.material.needsUpdate = true;
                }, undefined, () => {
                    const pngUrl = item.url.replace('small_mobile/', '').replace('.jpg', '.png');
                    lazyLoader.load(pngUrl, (tex2) => {
                        tex2.colorSpace = THREE.SRGBColorSpace;
                        item.material.map = tex2;
                        item.material.color.setHex(0xffffff);
                        item.material.needsUpdate = true;
                    });
                });
            });
        }

        function unloadRoomTextures(roomIdx) {
            if (!roomPosters[roomIdx]) return;
            roomStatus[roomIdx] = 'unloaded';
            roomPosters[roomIdx].forEach(item => {
                if (item.material.map) {
                    item.material.map.dispose(); 
                    item.material.map = null;
                }
                item.material.color.setHex(0x888888); 
                item.material.needsUpdate = true;
            });
        }

        function createBox(x, y, z, w, h, d, isWall = true, isDark = false, customMat = null, roomIndex) {
            let mat = customMat ? customMat : (isDark ? (isWall ? darkWallMat : darkFloorMat) : (isWall ? wallMat : floorMat));
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z); 
            mesh.receiveShadow = !isMobile;
            if(isWall) { 
                if (w > 1 && h > 1) mesh.castShadow = true;
                mesh.updateMatrixWorld(); 
                collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) }); 
            }
            addToRoom(mesh, roomIndex);
        }

        function createDoorWall(z, width, height, isDark = false, roomIndex) {
            const doorW = 4, doorH = 3.5, sideW = (width - doorW) / 2, thick = 0.5;
            createBox(-(width/2) + (sideW/2), height/2, z, sideW, height, thick, true, isDark, null, roomIndex);
            createBox((width/2) - (sideW/2), height/2, z, sideW, height, thick, true, isDark, null, roomIndex);
            createBox(0, doorH + (height-doorH)/2, z, doorW, height-doorH, thick, true, isDark, null, roomIndex);
        }

        function createHangingTV(x, z, ceilingHeight, rotationY = 0, roomIndex) {
            if (isMobile) return;

            const tvW = 1.78; const tvH = 3.16; const tvD = 0.1;
            const tvGeo = new THREE.BoxGeometry(tvW, tvH, tvD);
            const screenMat = new THREE.MeshBasicMaterial({ map: videoTex2 });
            const materials = [tvFrameMat, tvFrameMat, tvFrameMat, tvFrameMat, screenMat, tvFrameMat];
            const tv = new THREE.Mesh(tvGeo, materials);
            const tvY = 3.8; 
            tv.position.set(x, tvY, z); tv.rotation.y = rotationY; 
            addToRoom(tv, roomIndex);

            const tvTopY = tvY + (tvH / 2);
            const cableLen = ceilingHeight - tvTopY;
            const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen > 0 ? cableLen : 0.1);
            cableGeo.translate(0, cableLen / 2, 0); 
            const c1 = new THREE.Mesh(cableGeo, cableMat); c1.position.set(-tvW*0.3, tvH/2, 0); tv.add(c1);
            const c2 = new THREE.Mesh(cableGeo, cableMat); c2.position.set(tvW*0.3, tvH/2, 0); tv.add(c2);
            
            const screenLight = new THREE.PointLight(0xffffff, 2.0, 4.0); 
            screenLight.position.set(0, 0, 1.0); 
            tv.add(screenLight); 
            
            tv.userData.isObstacle = true; 
            collidableObjects.push({ customType: 'cylinder', mesh: tv, radius: 0.1, position: tv.position });
        }

        function createProjection(x, y, z, w, h, rotationY, texture, roomIndex) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide }));
            mesh.position.set(x, y, z); mesh.rotation.y = rotationY; 
            addToRoom(mesh, roomIndex);
            
            if(!isMobile) { 
                const light = new THREE.PointLight(0xaaaaff, 30, 25); 
                light.position.set(x + Math.sin(rotationY), y, z + Math.cos(rotationY)); 
                addToRoom(light, roomIndex); 
            }
        }

        const cachedPipeGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 12); 
        const cachedJointGeo = new THREE.SphereGeometry(0.09, 12, 8);

        function createScaffoldingStructure(x, z, roomIndex) {
            revolvingStage = new THREE.Group();
            revolvingStage.position.set(x, 0, z);
            
            if (isMobile) {
               // Empty on Mobile
            } else {
                const platform = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, metalness: 0.5 }));
                platform.position.y = 0.1; platform.receiveShadow = !isMobile; revolvingStage.add(platform);
                collidableObjects.push({ box: new THREE.Box3().setFromObject(platform) }); 

                const structureGroup = new THREE.Group(); structureGroup.position.y = 0.2; 
                const metalMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2, metalness: 0.8 });
                const w = 4; const h = 3.5; const d = 4;
                
                function addPipe(px, py, pz, height, axis) {
                    const mesh = new THREE.Mesh(cachedPipeGeo, metalMat);
                    mesh.position.set(px, py, pz);
                    mesh.scale.set(1, height, 1);
                    if (axis === 'z') mesh.rotation.x = Math.PI / 2; if (axis === 'x') mesh.rotation.z = Math.PI / 2;
                    mesh.castShadow = true; 
                    structureGroup.add(mesh); collidableObjects.push({ box: new THREE.Box3().setFromObject(mesh) });
                }
                function addJoint(jx, jy, jz) { 
                    const mesh = new THREE.Mesh(cachedJointGeo, metalMat); 
                    mesh.position.set(jx, jy, jz); structureGroup.add(mesh); 
                }
                
                addPipe(-w/2, h/2, -d/2, h, 'y'); addPipe(w/2, h/2, -d/2, h, 'y'); addPipe(-w/2, h/2, d/2, h, 'y'); addPipe(w/2, h/2, d/2, h, 'y');
                const levels = [0.2, h - 0.2];
                levels.forEach(lev => { addPipe(0, lev, -d/2, w, 'x'); addPipe(0, lev, d/2, w, 'x'); addPipe(-w/2, lev, 0, d, 'z'); addPipe(w/2, lev, 0, d, 'z'); });
                const cornersX = [-w/2, w/2]; const cornersZ = [-d/2, d/2];
                levels.forEach(lev => { cornersX.forEach(cx => { cornersZ.forEach(cz => { addJoint(cx, lev, cz); }); }); });
                
                function mountPoster(px, py, pz, ry, width, height, pipeYLevel, specificUrl = null) {
                    let data;
                    if (specificUrl) {
                        data = { wallUrl: specificUrl, fullUrl: specificUrl, title: "Special", id: 80 };
                    } else {
                        data = getNextImage();
                    }

                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, side: THREE.DoubleSide });
                    const tex = textureLoader.load(data.wallUrl, (t) => { t.colorSpace = THREE.SRGBColorSpace; mat.map = t; mat.needsUpdate = true; }, undefined, 
                    () => {
                        const pngUrl = data.wallUrl.replace('small/', '').replace('small_mobile/', '').replace('.jpg', '.png');
                        textureLoader.load(pngUrl, (t2)=>{ t2.colorSpace=THREE.SRGBColorSpace; mat.map=t2; mat.needsUpdate=true; });
                    });

                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.5), mat);
                    mesh.position.set(px, py, pz); mesh.rotation.y = ry;
                    
                    const stringMat = new THREE.LineBasicMaterial({ color: 0x111111 });
                    const topOfPosterY = 2.5 / 2; const distToPipe = (pipeYLevel - 0.05) - (py + topOfPosterY);
                    const pointsL = [new THREE.Vector3(-1 + 0.15, topOfPosterY, 0), new THREE.Vector3(-1 + 0.15, topOfPosterY + distToPipe, 0)];
                    const pointsR = [new THREE.Vector3(1 - 0.15, topOfPosterY, 0), new THREE.Vector3(1 - 0.15, topOfPosterY + distToPipe, 0)];
                    mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsL), stringMat)); mesh.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pointsR), stringMat));

                    mesh.userData = { type: 'poster', url: data.fullUrl, title: data.title, year: "2025", desc: "Mounted Installation" };
                    revolvingStage.add(mesh); postersArray.push(mesh);
                }
                const topPipeLevel = 3.3; const posterCenterY = 3.5 / 2;
                const d2 = 4; const w2 = 4;
                
                mountPoster(0, posterCenterY, d2/2, 0, 2, 2.5, topPipeLevel); 
                mountPoster(-w2/2, posterCenterY, 0, Math.PI/2, 2, 2.5, topPipeLevel); 
                mountPoster(0, posterCenterY, -d2/2, Math.PI, 2.5, 1.8, topPipeLevel); 
                mountPoster(w2/2, posterCenterY, 0, -Math.PI/2, 2, 2.5, topPipeLevel, 'assets/image80.jpg');

                revolvingStage.add(structureGroup);
            }
            addToRoom(revolvingStage, roomIndex);
        }

        function fixMaterial(object) {
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true; 
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.metalness = 0; 
                        child.material.roughness = 0.8; 
                    }
                }
            });
        }

        const modelFiles = ['1.glb', '2.glb', '3.glb', '4.glb', '5.glb', '6.glb', '8.glb'];
        
        function loadAllModels(roomCenterX, roomCenterZ, roomIndex) {
            const gltfLoader = new GLTFLoader(manager);
            modelFiles.forEach((filename, index) => {
                const angle = (index / modelFiles.length) * Math.PI * 2;
                const radius = 5; 
                const offsetX = Math.cos(angle) * radius; const offsetZ = Math.sin(angle) * radius;
                const fullPath = `assets/3d/${filename}`;
                
                gltfLoader.load(fullPath, (gltf) => {
                    const object = gltf.scene;
                    fixMaterial(object);
                    object.scale.set(1, 1, 1); 
                    const box = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3(); box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let targetScale = 1.0;
                    if (maxDim > 5) { targetScale = 3.0 / maxDim; } else if (maxDim < 0.5) { targetScale = 2.0 / maxDim; }
                    let multiplier = 2.3; 
                    if (filename === '3.glb') multiplier *= 0.8;
                    if (filename === '5.glb' || filename === '6.glb') multiplier = 1.9;
                    if (filename === '8.glb') multiplier = (2.3 / 3.0) * 1.4; 
                    targetScale *= multiplier;
                    object.scale.set(targetScale, targetScale, targetScale);
                    object.rotation.set(0, 0, 0); 
                    if (filename === '4.glb') animatedModels.push(object); 
                    object.updateMatrixWorld(); 
                    const newBox = new THREE.Box3().setFromObject(object);
                    object.position.set(roomCenterX + offsetX, -newBox.min.y, roomCenterZ + offsetZ);
                    addToRoom(object, roomIndex);
                    collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                    
                    if (filename === '6.glb') {
                        const loader9 = new GLTFLoader();
                        loader9.load('assets/3d/9.glb', (gltf9) => {
                            const obj9 = gltf9.scene;
                            fixMaterial(obj9);
                            const smallScale = (((1.9 / 4.0) * 1.4) / 3.0) * 1.5;
                            obj9.scale.set(smallScale, smallScale, smallScale); 
                            obj9.rotation.set(0, 0, 0);
                            animatedModels.push(obj9); 
                            const box6 = new THREE.Box3().setFromObject(object);
                            const topY = box6.max.y;
                            obj9.updateMatrixWorld();
                            const box9 = new THREE.Box3().setFromObject(obj9);
                            const heightOffset9 = -box9.min.y; 
                            obj9.position.set(object.position.x, topY * 1.45 + heightOffset9, object.position.z);
                            addToRoom(obj9, roomIndex);
                        });
                    }
                }, undefined, (e) => { console.error("Model fail", filename); });
            });
        }

        function createHangingModel7(x, z, roomCeiling, roomIndex) {
            const gltfLoader = new GLTFLoader(manager);
            gltfLoader.load('assets/3d/7.glb', (gltf) => {
                const object = gltf.scene;
                fixMaterial(object);
                object.scale.set(1.4, 1.4, 1.4); 
                object.rotation.set(0, 0, 0); 
                const hangY = 3.0; 
                object.position.set(x, hangY, z);
                addToRoom(object, roomIndex);
                collidableObjects.push({ box: new THREE.Box3().setFromObject(object) });
                const cableLen = roomCeiling - hangY;
                const cableGeo = new THREE.CylinderGeometry(0.01, 0.01, cableLen);
                cableGeo.translate(0, cableLen/2, 0);
                const cable = new THREE.Mesh(cableGeo, cableMat);
                cable.position.set(x, hangY, z);
                addToRoom(cable, roomIndex);
            });
        }

        // --- 5. WORLD GENERATION ---
        const roomsCount = isMobile ? 4 : 5;
        
        const roomSize = 20; const roomHeight = 6; 
        const whiteFloorL = roomSize * (roomsCount - (isMobile ? 0 : 1)); 
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, whiteFloorL), floorMat);
        floor1.rotation.x = -Math.PI / 2; floor1.position.z = -whiteFloorL / 2 + roomSize / 2; floor1.receiveShadow = !isMobile; scene.add(floor1);
        
        const zLastRoom = -((roomsCount - 1) * roomSize);
        // FIX: Sit in LAST room only. Init far away so Room 0 doesn't trigger it.
        let benchPosition = new THREE.Vector3(0, -9999, 0); 
        
        if (!isMobile) {
            const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkFloorMat);
            floor2.rotation.x = -Math.PI / 2; floor2.position.z = zLastRoom; scene.add(floor2);
        }

        for (let i = 0; i < roomsCount; i++) {
            const zCenter = -(i * roomSize);
            const isDarkRoom = (!isMobile && i === roomsCount - 1);
            
            if (!isDarkRoom) {
                if (isMobile) {
                    const roomLight = new THREE.PointLight(0xffffff, 1.5, 25);
                    roomLight.position.set(0, 5, zCenter);
                    addToRoom(roomLight, i);
                } else {
                    const rectLightLeft = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                    rectLightLeft.position.set(-8, 5.5, zCenter); rectLightLeft.lookAt(-20, 1, zCenter); addToRoom(rectLightLeft, i);
                    const rectLightRight = new THREE.RectAreaLight(0xffffff, 6.0, roomSize - 2, 0.5);
                    rectLightRight.position.set(8, 5.5, zCenter); rectLightRight.lookAt(20, 1, zCenter); addToRoom(rectLightRight, i);
                    const fillLight = new THREE.PointLight(0xffffff, 2, 20); fillLight.position.set(0, 5, zCenter); addToRoom(fillLight, i);
                }
            }

            createBox(-roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom, null, i); 
            createBox(roomSize/2, roomHeight/2, zCenter, 0.5, roomHeight, roomSize, true, isDarkRoom, null, i); 
            
            if (!isDarkRoom) {
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), wallMat);
                ceiling.rotation.x = Math.PI / 2; ceiling.position.set(0, roomHeight, zCenter); addToRoom(ceiling, i);
            }
            
            if (i === 0) {
                createBox(0, roomHeight/2, zCenter + roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom, null, i);
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, isDarkRoom, i);
                
                if (isMobile) {
                    addPoster( -3.5, 2.7, zCenter + roomSize/2 - 0.3, Math.PI, 2.2, 2.8, i); 
                    addPoster( 3.5, 2.7, zCenter + roomSize/2 - 0.3, Math.PI, 2.2, 2.8, i);  
                }

            } else if (isDarkRoom) {
                createBox(0, roomHeight/2, zCenter - roomSize/2, roomSize, roomHeight, 0.5, true, isDarkRoom, null, i);
                const darkCeiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), darkWallMat);
                darkCeiling.rotation.x = Math.PI / 2; darkCeiling.position.set(0, roomHeight, zCenter); addToRoom(darkCeiling, i);
                benchPosition.set(0, 0.4, zCenter);
                createBox(0, 0.4, zCenter, 3.5, 0.8, 1.5, true, false, benchMat, i);
            } else if (isMobile && i === roomsCount - 1) {
                createBox(0, roomHeight/2, zCenter - roomSize/2, roomSize, roomHeight, 0.5, true, false, null, i);
                // Create bench for mobile in last room
                benchPosition.set(0, 0.4, zCenter);
                createBox(0, 0.4, zCenter, 3.5, 0.8, 1.5, true, false, benchMat, i);
            } else {
                createDoorWall(zCenter - roomSize/2, roomSize, roomHeight, false, i);
                
                if (isMobile) {
                    addPoster( -3.5, 2.7, zCenter - roomSize/2 + 0.3, 0, 2.2, 2.8, i); 
                    addPoster( 3.5, 2.7, zCenter - roomSize/2 + 0.3, 0, 2.2, 2.8, i);  
                    
                    addPoster( -3.5, 2.7, zCenter + roomSize/2 - 0.3, Math.PI, 2.2, 2.8, i); 
                    addPoster( 3.5, 2.7, zCenter + roomSize/2 - 0.3, Math.PI, 2.2, 2.8, i); 
                }
            }
            
            if (!isDarkRoom) {
                if (i === 0) { createHangingTV(0, zCenter, roomHeight, 0, i); } 
                else if (i === 1) { loadAllModels(0, zCenter, i); createHangingModel7(0, zCenter, roomHeight, i); } 
                else if (i === 2) { createScaffoldingStructure(0, zCenter, i); } 
                else { 
                    let rotation = (i === 3) ? 0 : Math.random() * Math.PI;
                    createHangingTV(0, zCenter, roomHeight, rotation, i); 
                }
                
                const standardW = isMobile ? 2.2 : 2.6; 
                const standardH = isMobile ? 2.8 : 3.25; 
                const postersPerSide = isMobile ? 7 : 6; 
                const sideSpacing = isMobile ? 2.5 : 3.0; 
                
                const startZ = zCenter + (postersPerSide * sideSpacing / 2) - (sideSpacing / 2); 
                for (let k = 0; k < postersPerSide; k++) {
                    const zPos = startZ - (k * sideSpacing);
                    addPoster(-9.7, 2.7, zPos, Math.PI/2, standardW, standardH, i);
                    addPoster(9.7, 2.7, zPos, -Math.PI/2, standardW, standardH, i);
                }
                
                const offsetX = 6.0; const offsetZ = 0.3; 
                addPoster(-offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                addPoster(offsetX, 2.7, zCenter - roomSize/2 + offsetZ, 0, standardW, standardH, i);
                
                if (i > 0) { 
                   addPoster(-offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                   addPoster(offsetX, 2.7, zCenter + roomSize/2 - offsetZ, Math.PI, standardW, standardH, i);
                }
            } else {
                const projW = 9.0; const projH = 5.06;
                const wallDist = (roomSize/2) - 0.4;
                createProjection(0, 3, zCenter - wallDist, projW, projH, 0, videoTex1, i);
                if (!isMobile) {
                    createProjection(-wallDist, 3, zCenter, projW, projH, Math.PI/2, videoTex1, i);
                    createProjection(wallDist, 3, zCenter, projW, projH, -Math.PI/2, videoTex1, i);
                }
            }
        }

        // --- FOLLOWER LOGIC (Desktop Only) ---
        let isFollowing = true;
        let follower = null;
        
        if (!isMobile) {
            const followerTex = textureLoader.load('assets/gerb.png', undefined, undefined, (err) => console.error("Missing gerb.png"));
            followerTex.colorSpace = THREE.SRGBColorSpace;
            const followerGeo = new THREE.PlaneGeometry(3, 3);
            const followerMat = new THREE.MeshBasicMaterial({ map: followerTex, side: THREE.DoubleSide, transparent: true });
            follower = new THREE.Mesh(followerGeo, followerMat);
            follower.position.set(0, 2.5, 12); 
            follower.userData = { type: 'follower', title: "Watcher", desc: "Click to toggle following" };
            scene.add(follower);
            interactiveObjects.push(follower);
        }

        const ambientLight = new THREE.AmbientLight(0xffffff, isMobile ? 1.6 : 0.6); 
        scene.add(ambientLight);
        
        if (!isMobile) {
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); 
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 512; 
            dirLight.shadow.mapSize.height = 512;
            scene.add(dirLight);
        } else {
            const dirLightMobile = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLightMobile.position.set(5, 10, 7);
            scene.add(dirLightMobile);
        }

        // --- CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const sitHint = document.getElementById('sit-hint');
        const mobileSitBtn = document.getElementById('mobile-sit-btn');
        const viewBtn = document.getElementById('view-btn');
        const modal = document.getElementById('artwork-modal');
        const modalClose = document.getElementById('modal-close-btn');
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        const cursor = document.getElementById('cursor');

        let isModalOpen = false;
        let isSitting = false;
        let isGameActive = false;
        let currentTarget = null; 

        function startGame(e) {
            e.preventDefault(); e.stopPropagation();
            startScreen.style.display = 'none';
            isGameActive = true;
            bgMusic.play().catch(e => console.log("Audio block", e));
            if(!isMobile) {
                video1.play().catch(e => console.log("Video1 block", e));
                video2.play().catch(e => console.log("Video2 block", e));
            }
            if (!isMobile) {
                controls.lock();
            } else {
                document.getElementById('mobile-look-hint').style.display = 'block';
                // Trigger initial mobile load
                checkRoomLoad(0);
            }
        }

        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', startGame);
        
        modalClose.addEventListener('click', closeModal);
        modalClose.addEventListener('touchstart', (e) => { e.stopPropagation(); closeModal(); });

        // --- MOBILE CONTROLS ---
        const stickContainer = document.getElementById('stick-container');
        const stickKnob = stickContainer.querySelector('.stick-knob');
        let moveTouchId = null;
        let lookTouchId = null;
        let lookStartX = 0;
        let lookStartY = 0;
        let moveVector = { x: 0, y: 0 };
        let stickCenter = { x: 0, y: 0 };

        if(isMobile) {
            function handleTouchStart(e) {
                if (!isGameActive) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const halfWidth = window.innerWidth / 2;
                    if(isModalOpen) continue;

                    if (moveTouchId === null && t.clientX < halfWidth) {
                        moveTouchId = t.identifier;
                        stickContainer.style.display = 'block';
                        stickContainer.style.left = (t.clientX - 50) + 'px';
                        stickContainer.style.top = (t.clientY - 50) + 'px';
                        stickCenter = { x: t.clientX, y: t.clientY };
                        stickKnob.style.transform = `translate(-50%, -50%)`;
                    }
                    else if (lookTouchId === null && t.clientX > halfWidth) {
                        if (e.target.id === 'mobile-sit-btn' || e.target.id === 'view-btn' || e.target.id === 'modal-close-btn' || e.target.closest('#artwork-modal')) continue;
                        lookTouchId = t.identifier;
                        lookStartX = t.clientX;
                        lookStartY = t.clientY;
                    }
                }
            }

            function handleTouchMove(e) {
                if (!isGameActive || isModalOpen) return;
                e.preventDefault(); 
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        const maxDist = 50;
                        let dx = t.clientX - stickCenter.x;
                        let dy = t.clientY - stickCenter.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > maxDist) {
                            const ratio = maxDist / dist;
                            dx *= ratio;
                            dy *= ratio;
                        }
                        stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        moveVector.x = dx / maxDist;
                        moveVector.y = dy / maxDist;
                    }
                    else if (t.identifier === lookTouchId) {
                        const deltaX = (t.clientX - lookStartX) * 0.3; 
                        camera.rotation.y -= deltaX * 0.015;
                        lookStartX = t.clientX;
                        lookStartY = t.clientY;
                    }
                }
            }

            function handleTouchEnd(e) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        moveTouchId = null;
                        moveVector = { x: 0, y: 0 };
                        stickContainer.style.display = 'none';
                    }
                    if (t.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            }

            document.addEventListener('touchstart', handleTouchStart, {passive: false});
            document.addEventListener('touchmove', handleTouchMove, {passive: false});
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('click', () => { if (isModalOpen) closeModal(); });
            mobileSitBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); toggleSit(); });
            viewBtn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); e.stopPropagation(); 
                if (currentTarget) openModal(currentTarget.userData); 
            });
        } else {
            document.addEventListener('click', () => {
                if (isGameActive) {
                    if (isModalOpen) closeModal();
                    else { 
                        if (controls.isLocked) checkIntersectionAndClick(); 
                        else controls.lock(); 
                    }
                }
            });
        }

        function checkIntersectionAndClick() {
            raycaster.setFromCamera(center, camera);
            const objectsToCheck = [...postersArray, ...interactiveObjects];
            const intersects = raycaster.intersectObjects(objectsToCheck);
            if (intersects.length > 0 && intersects[0].distance < 8) {
                const obj = intersects[0].object;
                if (obj.userData.type === 'poster') {
                    if(isMobile) {
                        currentTarget = obj;
                        viewBtn.style.display = 'block';
                    } else {
                        openModal(obj.userData);
                    }
                } else if (obj.userData.type === 'follower') {
                    isFollowing = !isFollowing;
                }
            } else {
                if(isMobile) {
                    viewBtn.style.display = 'none';
                    currentTarget = null;
                }
            }
        }

        function openModal(data) {
            isModalOpen = true; 
            if (!isMobile) controls.unlock();
            const imgEl = document.getElementById('modal-img');
            imgEl.src = data.url; 
            document.getElementById('modal-title').innerText = data.title;
            document.getElementById('modal-desc').innerText = `${data.year} • ${data.desc}`;
            modal.style.display = 'flex';
            viewBtn.style.display = 'none';
        }

        function closeModal() { 
            isModalOpen = false; modal.style.display = 'none'; 
            if (!isMobile) controls.lock(); 
        }

        function toggleSit() {
            if (isSitting) { 
                isSitting = false; camera.position.y = 1.7; camera.fov = (isMobile && aspect < 1) ? 95 : 70; camera.updateProjectionMatrix();
                bgMusic.volume = 0.65;
                if(video1 && !isMobile) video1.muted = true;
                if(isMobile) mobileSitBtn.style.display = 'none';
            } else {
                const dist = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (dist < 5.0) {
                    isSitting = true; 
                    camera.position.set(benchPosition.x, benchPosition.y + 1.2, benchPosition.z); 
                    velocity.set(0, 0, 0);
                    camera.lookAt(0, 3, benchPosition.z - 20); 
                    camera.fov = (isMobile && aspect < 1) ? 60 : 40; camera.updateProjectionMatrix();
                    bgMusic.volume = 0.1;
                    if(video1 && !isMobile) { video1.muted = false; video1.volume = 1.0; }
                    if(isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "UP"; }
                }
            }
        }

        const move = { f: false, b: false, l: false, r: false, shift: false };
        const velocity = new THREE.Vector3();
        let canJump = false;

        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') move.f = true;
            if(e.code === 'KeyS') move.b = true;
            if(e.code === 'KeyA') move.l = true;
            if(e.code === 'KeyD') move.r = true;
            if(e.code === 'ShiftLeft') move.shift = true;
            if(e.code === 'Space' && canJump && !isSitting) { velocity.y += 12; canJump = false; }
            if(e.code === 'KeyC') toggleSit();
        });

        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') move.f = false;
            if(e.code === 'KeyS') move.b = false;
            if(e.code === 'KeyA') move.l = false;
            if(e.code === 'KeyD') move.r = false;
            if(e.code === 'ShiftLeft') move.shift = false;
        });

        let prevTime = performance.now();
        let lastRoomIndex = -1;

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameActive) return;
            const time = performance.now(); 
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            
            if (!isMobile) {
                if (revolvingStage) { revolvingStage.rotation.y += 0.1 * delta; }
                animatedModels.forEach(model => { model.rotation.y -= 1.0 * delta; });
            } else {
                animatedModels.forEach(model => { model.rotation.y -= 1.0 * delta; });
            }
            
            if (follower && isFollowing) {
                follower.lookAt(camera.position);
                const dist = follower.position.distanceTo(camera.position);
                if (dist > 3.0) {
                    const direction = new THREE.Vector3().subVectors(camera.position, follower.position).normalize();
                    follower.position.add(direction.multiplyScalar(3.5 * delta)); 
                    follower.position.y = 2.5 + Math.sin(time * 0.002) * 0.2; 
                }
            } else if (follower && !isFollowing) {
                follower.position.y = 2.5 + Math.sin(time * 0.002) * 0.2;
            }

            if (!isSitting) {
                const distToBench = camera.position.distanceTo(new THREE.Vector3(benchPosition.x, camera.position.y, benchPosition.z));
                if (distToBench < 5.0) { if (isMobile) { mobileSitBtn.style.display = 'flex'; mobileSitBtn.innerText = "SIT"; } else { sitHint.style.display = 'block'; } } 
                else { sitHint.style.display = 'none'; if (isMobile && !isSitting) mobileSitBtn.style.display = 'none'; }
                
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 30.0 * delta; 
                
                const speed = (move.shift ? 150 : 72);
                
                const direction = new THREE.Vector3();
                
                if (isMobile) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();
                    if (moveVector.x !== 0 || moveVector.y !== 0) {
                        velocity.x += (right.x * moveVector.x + forward.x * moveVector.y) * speed * delta;
                        velocity.z += (right.z * moveVector.x + forward.z * moveVector.y) * speed * delta;
                    }
                } else {
                    direction.z = Number(move.f) - Number(move.b);
                    direction.x = Number(move.r) - Number(move.l);
                    direction.normalize();
                    if (move.f || move.b) velocity.z -= direction.z * speed * delta;
                    if (move.l || move.r) velocity.x -= direction.x * speed * delta;
                    controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
                }
                
                if(isMobile) { camera.position.add(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); }
                camera.position.y += velocity.y * delta;
                if (camera.position.y < 1.7) { velocity.y = 0; camera.position.y = 1.7; canJump = true; }
                
                if (camera.position.y < -10) {
                    camera.position.set(0, 1.7, 8);
                    velocity.set(0, 0, 0);
                }

                const pPos = camera.position;
                const pBox = new THREE.Box3(new THREE.Vector3(pPos.x-0.4, pPos.y-1, pPos.z-0.4), new THREE.Vector3(pPos.x+0.4, pPos.y+1, pPos.z+0.4));
                let hit = false;
                for(let obj of collidableObjects) {
                    if (obj.box && pBox.intersectsBox(obj.box)) hit = true;
                    if (obj.customType === 'cylinder') {
                        const dist = Math.sqrt(Math.pow(pPos.x - obj.position.x, 2) + Math.pow(pPos.z - obj.position.z, 2));
                        if (dist < obj.radius && Math.abs(pPos.y - obj.position.y) < 2.0) hit = true;
                    }
                }
                if(hit) { 
                    if(isMobile) { camera.position.sub(new THREE.Vector3(velocity.x * delta, 0, velocity.z * delta)); } 
                    else { controls.moveForward(velocity.z * delta); controls.moveRight(velocity.x * delta); }
                }
                
                if (isMobile) {
                    const currentRoom = Math.max(0, Math.round(-camera.position.z / 20));
                    if (currentRoom !== lastRoomIndex) {
                        lastRoomIndex = currentRoom;
                        checkRoomLoad(currentRoom);
                    }
                    if (!isModalOpen) checkIntersectionAndClick();
                }

            } else { sitHint.style.display = 'none'; velocity.set(0,0,0); }
            
            if (!isMobile) {
                raycaster.setFromCamera(center, camera);
                const hoverCheck = [...postersArray, ...interactiveObjects];
                const intersects = raycaster.intersectObjects(hoverCheck);
                if (intersects.length > 0 && intersects[0].distance < 8) cursor.classList.add('hover-active'); else cursor.classList.remove('hover-active');
            }
            
            prevTime = time;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const asp = window.innerWidth / window.innerHeight;
            camera.aspect = asp;
            camera.fov = (isMobile && asp < 1) ? 95 : 70;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>